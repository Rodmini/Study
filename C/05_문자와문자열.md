# 05 문자와 문자열
## 21. 문자와 문자열 관련 함수
### 21.1 스트림과 데이터의 이동
#### 21.1.1 무엇이 입력이고 무엇이 출력인가?
- 데이터의 입력과 출력은 프로그램의 흐름을 뜻하는 것이다.
- 프로그램을 중심으로 안으로 데이터가 흘러 들어오는 것이 입력이고, 프로그램 밖으로 데이터가 흘러 나가는 것이 출력이다.
  + 가장 대표적인 입력장치로는 키보드가 있으며, 파일도 입력의 대상이 될 수 있다.
  + 가장 대표적인 출력장치로는 모니터가 있으며, 파일 역시 출력의 대상이 될 수 있다.
  + 컴퓨터에 연결이 가능한 마우스, 프린터, 화상 카메라와 같은 기타 장치들도 입출력 장치에 해당한다.
#### 21.1.2 데이터의 이동수단이 되는 스트림
- 프로그램상에서 모니터로 문자열을 출력할 수 있는 이유는 무엇인가?
  + 프로그램과 모니터, 프로그램과 키보드는 기본적으로 연결되어 있는 개체가 아닌, 서로 떨어져 있는 개체이다.
  + 따라서, 프로그램상에서 모니터와 키보드를 대상으로 데이터를 입출력 하기 위해서는 이들을 연결시켜주는 다리가 필요하다.
  + 이러한 다리의 역할을 하는 매개체를 가리켜 **스트림(stream)** 이라 한다.
    - **출력 스트림**: 실행중인 프로그램과 모니터를 연결해줌
    - **입력 스트림**: 실행중인 프로그램과 키보드를 연결해줌
- 다리의 역할을 하는 스트림의 정체는?
  + 운영체제가 외부장치와 프로그램과의 데이터 송수신의 도구가 되는 스트림을 제공한다.
  + Chapter 24의 경우 파일 기반의 데이터 입출력을 학습하게 되는데, 이 때 실행중인 프로그램과 하드 디스크에 저장되어 있는 파일과의 연결을 위한 스트림의 형성을 우리가 직접 운영체제에게 요구하게 된다.
#### 21.1.3 스트림의 생성과 소멸
- 콘솔(일반적으로 키보드와 모니터를 의미함) 입출력과 파일 입출력 사이에는 차이점이 하나 있다.
  + 파일과의 연결을 위한 스트림의 생성은 우리가 직접 요구해야 하지만!
  + 콘솔과의 연결을 위한 스트림의 생성은 요구할 필요가 없다는 것이다!
    - 즉, 콘솔 입출력을 위한 스트림은 자동으로 생성이 된다. (ex. printf, scanf 함수)
    - **콘솔 입출력을 위한 '입력 스트림'과 '출력 스트림'은 프로그램이 실행되면 자동으로 생성되고, 종료되면 자동으로 소멸**
    - 즉, 이 둘은 기본적으로 제공되는 '표준 스트림(standard stream)'이다. 그리고 여기엔 '에러 스트림'도 존재한다.

표준스트림|-|설명
-----|------------|----------------
stdin|표준 입력 스트림|키보드 대상으로 입력
stdout|표준 출력 스트림|모니터 대상으로 출력
stderr|표준 에러 스트림|모니터 대상으로 출력
- '표준 에러 스트림'과 '표준 출력 스트림'은 모니터로 출력이 이뤄진다는 점에서 큰 차이가 없으나,
- 이후에 '입출력 리다이렉션(redirection)'이라는 기술을 익히고 나면(보통 리눅스나 유닉스를 접하면서 공부하게 됨), 표준 에러 스트림의 출력 대상을 변경시킬 수 있어서 stdout과 stderr의 용도를 구분할 수 있게 될 것이다.
- **스트림(stream): 한 방향으로 흐르는 데이터의 흐름** 을 뜻한다. 즉 단 방향으로만 데이터의 전송이 이루어짐.

### 21.2 문자 단위 입출력 함수
#### 21.2.1 문자 출력 함수: putchar, fputc
- 모니터로 하나의 문자를 출력할 때 일반적으로 사용하는 두 함수는 다음과 같다.
```c
  #include <stdio.h>
  int putchar(int c);
  int fputc(int c, FILE * stream);
  // 함수호출 성공 시 쓰여진 문자정보가, 실패 시 EOF 반환
```
- putchar 함수는 인자로 전달된 문자정보를 stdout으로 표현되는 표준 출력 스트림으로 전송하는 함수이다.
  + 따라서 인자로 전달된 문자를 모니터로 출력하는 함수라 할 수 있다.
- 문자를 전송한다는 측면에서 fputc 함수도 putchar 함수와 동일하지만,
- **fputc 함수는 문자를 전송할 스트림을 지정할 수 있다.** 즉, stdout 뿐만 아니라, 파일을 대상으로도 데이터 전송 가능
  + fputc 함수의 두 번째 매개변수 stream은 문자를 출력할 스트림의 지정에 사용되므로 이 인자에 표준 출력 스트림을 의미하는 stdout을 전달하면, putchar 함수와 동일한 함수가 된다.
  + fputc 함수의 두 번째 인자로 파일의 스트림 정보를 전달하면, 해당 파일로 문자가 전달된다(해당 파일에 문자가 저장된다). 때문에 fputc 함수는 이후에 파일 입출력에서도 쓰임
#### 21.2.2 문자 입력 함수: getchar, fgetc
- 키보드로부터 하나의 문자를 입력 받을 때 일반적으로 사용하는 두 함수는 다음과 같다.
```c
  #include <stdio.h>
  int getchar(void);
  int fgetc(FILE * stream);
  // 파일의 끝에 도달하거나 함수호출 실패 시 EOF 반환
```
- getchar 함수는 stdin으로 표현되는 표준 입력 스트림으로부터 하나의 문자를 입력 받아서 반환하는 함수이다. 따라서 키보드로부터 하나의 문자를 입력 받는 함수라 할 수 있다.
- fgetc 함수도 하나의 문자를 입력 받는 함수이다. 다만, getchar와 달리 문자를 입력 받을 스트림을 지정할 수 있다.
```c
  int main(void) {
    int ch1, ch2;
    ch1 = getchar();    // 문자 입력
    ch2 = fgetc(stdin); // 엔터 키 입력

    putchar(ch1);       // 문자 출력
    fputc(ch2, stdout); // 엔터 키 출력
    return 0;
  }
```
```c
  // 수행 결과
  g
  g
  Program ended with exit code: 0
```
- 소스코드상에서는 분명 두 개의 문자를 입출력하고 있으나, 실행결과를 보면 하나의 문자만 보인다.
- 왜? 두 번째 문자가 '엔터 키'이기 때문이다. 사실 상 '엔터 키'도 아스키 코드 값이 10인 '\n' 문자이므로!
- 예제에서 문자를 int형 변수에 저장하는 이유?
  + 언뜻 보기에는 char형으로 선언해야 할 것 같지만, **int형으로 선언해야 한다.**
  + 앞서 정의한 함수의 원형에서 알 수 있듯이 getchar 함수와 fgetc 함수의 반환형이 int이므로...
  + 그러면 왜 반환형은 int형 일까?
#### 21.2.3 문자 입출력에서의 EOF
- **EOF(End Of File)**: 파일의 끝을 표현하기 위해서 정의해 놓은 상수이다.
- 따라서, 파일을 대상으로 fgetc 함수가 호출되면, 그리고 그 결과로 EOF가 반환되면, 이는 '파일의 끝에 도달해서 더이상 읽을 내용이 없다'는 뜻
- 그렇다면 키보드를 대상으로 하는 fgetc 함수와 getchar 함수는 언제 EOF를 반환할까?
  + 함수호출의 실패
  + Windows에서 CTRL + Z키, Linux에서 CTRL + D 키가 입력되는 경우
- 키보드의 입력에 '파일의 끝'이라는 것이 존재할 수 없으므로 EOF의 반환시기를 CTRL+Z 또는 CTRL+D키의 입력으로 별도로 약속한 것
```c
  int main(void) {
    int ch;

    while(1) {
      ch = getchar();
      if (ch == EOF)
        break;
      putchar(ch);
    }
    return 0;
  }
```
```c
  // 수행 결과
  Hi~
  Hi~
  I like C lang.
  I like C lang.
  ^Z
```
- getchar 함수는 하나의 문자 뿐만 아니라 **공백을 포함하는 문장** 을 입력해도 된다.
#### 21.2.4 반환형이 int이고, int형 변수에 문자를 담는 이유는?
```c
  int getchar(void);
  int fgetc(FILE * stream);
```
- 반환되는 것은 1바이트 크기의 문자인데, 반환형이 int이다. 왜?
  + Chapter 05에서 언급했듯이, **char를 unsigned char로 처리하는 컴파일러도 존재한다.**
  + 위의 두 함수가 반환하는 값 중 하나인 **EOF는 -1로 정의된 상수** 이다.
  + 따라서 반환형이 char형이라면, 그리고 char를 unsigned char로 처리하는 컴파일러에 의해서 컴파일이 되었다면,
  + EOF는 반환의 과정에서 엉뚱한 양의 정수로 형 변환이 되어버리고 만다.
  + 그래서 **어떠한 상황에서도 -1을 인식할 수 있는 int형으로 반환형을 정의해 놓은 것**
- 문자 단위 입출력 함수의 존재이유!
  + printf, scanf 함수를 쓰는데 불편함도 없는데 왜 문자 단위 입출력 함수를 제공할까?
  + printf와 scanf 함수는 본래 서식지정을 통해서 새로운 입출력의 형태를 구성하는 함수이다.
    - 화려한 기능을 제공하는 만큼, 사용하는 메모리 공간도 크고, 해야 할 연산의 양도 많아 상대적으로 속도가 느리다.
    - 뿐만 아니라, 별도의 서식지정을 해야해서 문장을 구성하는 것이 번거롭다.
    - 그러므로, 단순히 문자 하나를 입출력 하는 것이 목적이라면 printf, scanf 함수보다는 위 함수들을 사용하는 것이 낫다.
### 21.3 문자열 단위 입출력 함수
- printf와 scanf 함수를 이용해도 문자열의 입출력이 가능하다.
- 그러나, scanf 함수는 공백이 포함된 형태의 문자열을 입력 받는데 제한이 있다.
- 다음의 문자열 입력 함수를 이용하면 공백을 포함하는 문자열도 입력 받을 수 있다.
#### 21.3.1 문자열 출력 함수: puts, fputs
```c
  #include <stdio.h>
  int puts(const char * s);
  int fputs(const char * s, FILE * stream);
  // 성공 시 0이 아닌 값을, 실패 시 EOF 반환
```
- puts 함수는 출력의 대상이 stdout으로 결정되어 있지만, fputs 함수는 두 번째 인자를 통해서 출력의 대상을 결정 가능
- 둘 다 첫 번째 인자로 전달되는 주소 값의 문자열을 출력하지만, 출력의 형태에 있어 한 가지 차이점이 있다.
```c
  char * str = "Simple String";

  printf("1. puts test ---------- \n");
  puts(str);
  puts("So Simple String");

  printf("2. fputs test ---------- \n");
  fputs(str, stdout); printf("\n");
  fputs("So Simple String", stdout); printf("\n");

  printf("3. end of main ---------- \n");
  return 0;
```
- **puts 함수가 호출되면 문자열 출력 후 자동으로 개행이 이뤄지지만, fputs 함수가 호출되면 문자열 출력 후 자동으로 개행이 이뤄지지 않는다!!!**
#### 21.3.2 문자열 입력 함수: gets, fgets
```c
  #include <stdio.h>
  char * gets(char * s);
  char * fgets(char * s, int n, FILE * stream);
  // 파일의 끝에 도달하거나 함수호출 실패 시 NULL 포인터 반환
```
```c
  char str[7];    // 7바이트의 메모리 공간 할당
  gets(str);      // 입력 받은 문자열을 배열 str에 저장
  ...
```
- 위의 문장구성만으로도 키보드로부터 문자열을 입력 받을 수 있으나,
- 배열의 크기를 초과하는 길이의 문자열 입력시 할당 받지 않은 메모리 공간을 침범하여 실행 중 오류가 발생하게 된다.
- 그러므로 가급적이면 다음의 형태로 fgets 함수를 호출하는 것이 좋다.
```c
  char str[7];
  fgets(str, sizeof(str), stdin);     // stdin으로부터 문자열 입력 받아서 str에 저장
  ...
```
- **stdin으로부터 문자열을 입력 받아서 배열 str에 저장하되, sizeof(str)의 길이만큼만 저장해라!**
  + `"123456789"`의 형태로 입력 받으면 sizeof(str)의 반환 값인 7보다 하나가 작은 6에 해당하는 문자열 `"123456"` 저장
  + 왜 size의 길이보다 1 작은 문자열이 저장되는가? ===> 문자열을 입력받으면 문자열의 끝에 자동으로 널 문자가 추가되므로...
    ```c
      int main(void) {
        char str[7];
        int i;

        for (i = 0; i < 3; i++) {
          fgets(str, sizeof(str), stdin);
          printf("Read %d: %s \n", i + 1, str);
        }
        return 0;
      }
    ```
    ```c
      // 수행 결과
      12345678901234567890
      Read 1: 123456
      Read 2: 789012
      Read 3: 345678
      Program ended with exit code: 0
    ```
    - 입력된 문자열의 길이가 배열의 길이를 넘어서다 보니, fgets 함수는 7보다 하나 작은 6의 길이만큼만 문자열 읽어들임
    - 따라서 프로그램 사용자는 딱 한번 입력하였지만, fgets 함수는 3회 모두 호출되었다.
    ```c
      int main(void) {
        char str[6];
        int i;

        for (i = 0; i < 3; i++) {
            fgets(str, sizeof(str), stdin);
            printf("Read %d: %s \n", i + 1, str);     // printf 함수 안에 개행이 포함되어 있다.
        }
        return 0;
      }
    ```
    ```c
      // 수행 결과
      We
      Read 1: We

      like
      Read 2: like

      you
      Read 3: you

      Program ended with exit code: 0
    ```
    - 그런데 실행 결과를 보면 문장이 출력될 때마다 개행이 두 번 이뤄졌음을 알 수 있다. 왜?
    - **fgets 함수는 \n을 만날 때 까지 문자열을 읽어 들이는데, \n을 제외시키거나 버리지 않고 문자열의 일부로 받아들임**
    - 즉, 키보드로 입력한 엔터 키의 정보까지도 문자열의 일부로 저장되는 것이다.
    ```c
      Y & I
      Read 1: Y & I

      ha ha
      Read 2: ha ha

      ^^ --
      Read 3: ^^ --

      Program ended with exit code: 0
    ```
    - 또한 fgets 함수는 '\n'을 만날 때 까지 문자열을 읽어 들이므로, **공백 문자를 포함하는 문자열의 입력이 가능하다.**
### 21.4 표준 입출력과 버퍼
#### 21.4.1 표준 입출력 기반의 버퍼
- ANSI C의 표준에서 정의된 함수들을 가리켜 '표준 입출력 함수'라 한다. (ex. printf, scanf, fputc, fgetc...)
- 표준 입출력 함수를 통해서 데이터를 입출력하는 경우, **해당 데이터들은 운영체제가 제공하는 '메모리 버퍼'를 중간에 통과하게 된다.**
- **메모리 버퍼**: 데이터를 임시로 모아두는(저장하는) 메모리 공간이다.
- 키보드를 통해 입력되는 데이터는, 일단 입력버퍼에 저장된 다음에(버퍼링 된 다음에) 프로그램에서 읽혀진다.
- 즉, fgets 함수가 읽어 들이는 문자열은 입력버퍼에 저장된 문자열이다.
- 키보드로부터 입력된 데이터가 입력 스트림을 거쳐 입력버퍼로 들어가는 시점은 **엔터 키가 눌리는 시점** 이다.
- 그래서 키보드로 아무리 문자열을 입력해도 엔터 키가 눌리기 전에는 fgets 함수가 문자열을 읽어 들이지 못하는 것이다.
- 엔터 키가 눌러지기 전에는 입력버퍼가 비워져 있다.
#### 21.4.2 버퍼링(Buffering)을 하는 이유는 무엇인가?
- 데이터를 목적지로 바로 전송하지 않고 중간에 출력버퍼와 입력버퍼를 둬서 전송하고자 하는 데이터를 임시 저장하는 이유는?
- **데이터 전송의 효율성** 과 관련이 있다. 키보드나 모니터와 같은 외부 장치와의 데이터 입출력은 생각보다 시간이 걸리는 작업이다.
- 따라서 키보드가 눌릴 때마다 눌린 문자의 정보를 목적지로 바로 이동시키는 것보다 중간에 메모리 버퍼를 둬서 데이터를 한데 묶어서 이동시키는 것이 보다 효율적이고 빠르다.
  + ex. 창고에 물건을 나르는 경우 손으로 하나씩 나르는 것보다 손수레에 가득 채워 나르는 것이 빠르다.
#### 21.4.3 출력버퍼를 비우는 fflush 함수
- 출력버퍼가 비워진다는 것은 **출력버퍼에 저장된 데이터가 버퍼를 떠나서 목적지로 이동됨** 을 뜻한다.
- 그런데, 출력버퍼가 비워지는 시점은 시스템에 따라, 버퍼의 성격에 따라 달라진다.
  + 버퍼가 꽉 찼을 때 비워지는 버퍼도 있고, 하나의 문장이 완전히 입력되었을 때마다 비워지는 버퍼도 있다.
- 이처럼 버퍼가 비워지는 시점은 동일하지 않으므로 다음 함수를 알아 둘 필요가 있다.
```c
  #include <stdio.h>
  int fflush(FILE * stream);
  // 함수호출 성공 시 0, 실패 시 EOF 반환
```
- 위 함수는 인자로 전달된 스트림의 버퍼를 비우는 기능을 제공한다.
- `fflush(stdout);` ==> 표준 출력버퍼를 비워라!
- fflush 함수는 파일을 대상으로도 호출이 가능하다.
- 그러나 콘솔 입출력을 하는 상황이거나, Windows나 Linux와 같은 범용 OS를 사용중이라면 stdout을 대상으로 fflush 함수를 호출할 일은 사실상 많지 않다.
#### 21.4.4 입력버퍼는 어떻게 비워야 하나요?
- 입력버퍼의 비워짐과 출력버퍼의 비워짐은 개념적으로 차이가 있다.
- '출력버퍼의 비워짐'이 저장된 데이터가 목적지로 전송됨을 의미하는 반면,
- '입력버퍼의 비워짐'은 데이터의 소멸을 의미하기 때문이다.
- `fflush(stdin);` ==> 어떠한 의미로 해석이 될까?
  + fflush 함수는 출력버퍼를 대상으로 호출하는 함수이다. C언어의 표준에서는 위의 결과에 대해 정의하고 있지 않다.(예측불가능)
  + 일부 컴파일러는 위의 형태로 함수가 호출되었을 때 입력버퍼를 비워주기도 하지만(ex.Windows 계열의 컴파일러) 그 이외의 컴파일러들은 전혀 다른 결과를 보인다.
  ```c
    int main(void) {
      char perID[7];
      char name[10];

      fputs("주민번호 앞 6자리 입력: ", stdout);
      fgets(perID, sizeof(perID), stdin);

      fputs("이름 입력: ", stdout);
      fgets(name, sizeof(name), stdin);

      printf("주민번호: %s \n", perID);
      printf("이름: %s \n", name);
      return 0;
    }
  ```
  ```c
    // 수행 결과
    주민번호 앞 6자리 입력: 370410
    이름 입력: 주민번호: 370410
    이름:

    Program ended with exit code: 0
  ```
  + 이름을 입력할 기회도 얻지 못한 채 프로그램이 종료되어 버리는 현상이 발생한다.
    - 위의 실행에서 입력한 데이터는 `360410\n` ==> 엔터 키를 포함하여 총 7문자가 입력되었다.
    - 그런데 fgets 함수로 전달될 때 널 문자를 제외하고 최대 6문자를 읽어 들인다. 따라서 \n을 제외한 나머지 여섯 문자만 읽혀지고 \n은 입력버퍼에 남아있게 된다.
    - 그리고 그 다음 fgets 함수가 호출되는데 이 함수는 \n을 만날 때까지 읽어들이는 함수이므로, 버퍼에 남아있는 \n만 읽어버리고 만다.
  + 위와 같은 문제를 해결하기 위해서는 예제 실행 중간에, 입력버퍼에 남아있는 \n 문자 하나만 지워버리면 된다.
  ```c
    void ClearLineFromReadBuffer(void) {
      while(getchar() != '\n');
    }
  ```
  + 입력버퍼에 저장된 문자들은 읽어들이면 지워진다. 그래서 \n을 만날 때까지 문자를 읽어 들이는 함수를 정의하였다.
  ```c
    void ClearLineFromReadBuffer(void) {
      while(getchar() != '\n');
    }

    int main(void) {
      char perID[7];
      char name[10];

      fputs("주민번호 앞 6자리 입력: ", stdout);
      fgets(perID, sizeof(perID), stdin);
      ClearLineFromReadBuffer();        // 입력버퍼 비우기

      fputs("이름 입력: ", stdout);
      fgets(name, sizeof(name), stdin);

      printf("주민번호: %s \n", perID);
      printf("이름: %s \n", name);
      return 0;
    }
  ```
  ```c
    // 수행 결과
    주민번호 앞 6자리 입력: 360410-2222222
    이름 입력: ioio
    주민번호: 360410
    이름: ioio

    Program ended with exit code: 0
  ```
  + 사용자가 잘못 입력하더라도, 필요한 만큼만 읽어들이고 나머지는 지워버리므로 정상적으로 동작한다.

### 21.5 입출력 이외의 문자열 관련 함수
- 표준 C에서는 문자열과 관련된 다양한 함수들을 정의하고 있다.
- 헤더파일 string.h에 선언된 문자열 관련 함수들 중 사용 빈도수가 높은 몇몇 함수를 소개
#### 21.5.1 문자열의 길이를 반환하는 함수: strlen
- 인자로 전달된 문자열의 길이를 반환하는 함수로 문자열과 관련해서 많이 사용되는 대표적인 함수이다.
```c
  #include <stdio.h>
  size_t strlen(const char * s);
  // 전달된 문자열의 길이를 반환하되, 널 문자는 길이에 포함되지 않는다.
```
- 위 함수의 반환형 `size_t`는 다음과 같이 선언되어 있다.
  + `typedef unsigned int size_t;` ==> unsigned int의 선언을 size_t로 대신할 수 있다!
  ```c
    size_t len;
    unsigned int len;
  ```
  + 위의 두 선언은 완전히 동일하다.
```c
  int main(void) {
    char str[] = "1234567";
    printf("%u \n", strlen(str));   // 문자열의 길이 7이 출력된다.
  }
```
- 반환형이 size_t이므로 unsigned int형 변수에 저장하고 `%u`서식문자로 출력하는 것이 정확하지만,
- 문자열의 길이정보는 아무리 길어도 int형 변수에 저장이 가능하고, %d로 출력이 가능하며 이렇게 사용하는 것이 더 흔하다.
- 예제> fgets 함수호출을 통해 문자열을 입력 받고 싶은데, 같이 딸려오는 \n 문자는 문자열에서 제외하고 싶다!
  ```c
    #include <stdio.h>
    #include <string.h>

    void RemoveBSN(char str[]) {
      int len = strlen(str);
      str[len-1] = 0;     // \n이 저장된 위치에 널 문자 저장
    }

    int main(void) {
      char str[100];
      printf("문자열 입력: ");
      fgets(str, sizeof(str), stdin);
      printf("길이: %d, 내용: %s \n", strlen(str), str);

      RemoveBSN(str);
      printf("길이: %d, 내용: %s \n", strlen(str), str);
      return 0;
    }
  ```
  ```c
    // 수행 결과
    문자열 입력: My Pearl
    길이: 9, 내용: My Pearl

    길이: 8, 내용: My Pearl
    Program ended with exit code: 0
  ```
  + fgets 함수호출을 통해 문자열을 입력받으면 \n문자가 문자열의 일부로 포함된다.
  + 아스키 코드 값 0은 널 문자를 의미. 이로써 \n은 문자열에서 사라지게 되는 셈이다.
#### 21.5.2 문자열을 복사하는 함수들: strcpy, strncpy
