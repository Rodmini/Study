# 03 배열과 포인터
## 11. 1차원 배열
### 11.1 배열의 이해와 선언 및 초기화 방법
- **배열**: 둘 이상의 변수를 모아 놓은 것. 다수의 데이터를 저장하고 처리하는 경우에 유용하다.
#### 11.1.1 1차원 배열의 선언에 필요한 것 3가지: 배열이름, 자료형, 길이정보
```c
  //자료형   이름  길이
  int oneDimArr [4];
```
```c
  int len = 20;
  int arr[len];   // 변수 len을 이용한 배열의 길이 선언이 가능하다.
```
- 과거의 C 표준에서는 배열의 길이정보를 반드시 상수로 지정하도록 제한하였다.
- 이러한 제약사항을 여전히 고수하고 있는 컴파일러도 다수 존재하므로, 가급적 **배열의 길이정보는 상수로** 지정!
- 배열의 위치 정보를 명시하는 인덱스 값은 1이 아닌 0에서부터 시작한다.
- 배열의 모든 요소는 반복문을 이용해서 순차적으로 접근하는 것이 가능하다.
#### 11.1.2 배열! 선언과 동시에 초기화하기!
1. `int arr1[5] = {1,2,3,4,5};      // 순차적으로 1,2,3,4,5로 초기화 한다.`
2. `int arr2[] = {1,2,3,4,5,6,7};   // 컴파일러에 의해서 자동으로 7이 삽입됨`
  * 이렇게 배열의 길이정보를 생략해도, 컴파일러가 초기화 리스트의 수를 참조하여 길이정보를 채워준다.
3. `int arr3[5] = {1,2};            // 3,4,5번째 배열요소는 0으로 채워짐`
- 배열의 이름을 대상으로 하는 sizeof 연산의 결과로는 '바이트 단위의 배열크기'가 반환된다.
  + `printf("%d \n", sizeof(arr1));   // 5*4 = 20`

### 11.2 배열을 이용한 문자열 변수의 표현
- char형 배열을 이용하면 문자열의 저장뿐만 아니라 문자열의 변경도 가능해진다.
#### 11.2.1 char형 배열의 문자열 저장과 '널(null)'문자
- **C언어에서는 큰 따옴표를 이용해서 문자열을 표현한다.**
  ```c
    char str[14] = "Good morning!";
    char str[] = "Good morning!";
  ```
  이렇게 컴파일러가 문자열의 길이를 계산하도록 설정해도 된다.
- 문자열의 저장을 목적으로 char형 배열을 선언할 경우에는 특수문자(escape sequence) `\0`이 저장될 공간까지 고려해야 한다.
- **널(null)** 문자: 문자열의 끝에 자동으로 삽입되는 문자 `\0`
  ```c
    printf("널 문자 문자형 출력: %c \n", str[13]);  //
    printf("널 문자 정수형 출력: %d \n", str[13]);  // 0
  ```
  널 문자의 아스키 코드 값은 0이라는 것을 알 수 있다. 그리고 문자의 형태로 출력할 경우, 아무런 출력이 발생하지 않는다.
  + **널 문자와 공백 문자는 엄연히 다르다!** 널 문자의 아스키코드 값은 0, 공백 문자의 아스키코드 값은 32

#### 11.2.2 scanf 함수를 이용한 문자열의 입력
```c
  char str[50];
  scanf("%s", str);   // 문자열을 입력 받아서 배열 str에 저장!
```
- **scanf 함수 호출문 구성 시, 데이터를 저장할 변수의 이름 앞에는 & 연산자를 붙여줘야 한다.**
- **그러나, 문자열을 입력 받는 배열의 이름 앞에는 & 연산자를 붙이지 않는다.**
- scanf 함수를 통해서 입력 받은 문자열의 끝에도 널 문자가 삽입되어 있다.
- **C언어에서 표현되는 모든 문자열의 끝에는 널 문자가 자동으로 삽입된다!**
- **널 문자가 존재하면 문자열이고, 널 문자가 존재하지 않으면 문자열이 아니다!**
  ```c
    char arr1[] = {'H', 'i', '~'};        // 마지막에 널 문자가 없으므로 문자 배열
    char arr2[] = {'H', 'i', '~', '\0'};  // 마지막에 널 문자가 있으므로 문자열
  ```

#### 11.2.3 문자열의 끝에 '널(null)' 문자가 필요한 이유
- 메모리상에서 문자열은 이진 데이터로 저장되기 때문에 문자열의 시작과 끝이 표시되어 있지 않다면 문자열을 구분하는 것이 불가능하다.
- `char str[100] = "~~~";`  str[0]이 문자열의 시작위치고, 문자열의 끝에는 널 문자가 삽입되어 있겠구나...
- 널 문자의 아스키코드 값은 0이므로 다음 두 문장은 동일한 문장이다.
  ```c
    str[8] = '\0';
    str[8] = 0;
  ```
#### 11.2.4 scanf 함수의 문자열 입력특성
- scanf 함수로 `"He is my friend!"` 라는 문자열을 입력 받으면 `"He"`만 입력된다.
- scanf 함수는 공백을 기준으로 데이터를 구분 짓는 함수이기 때문에, 문장을 입력 받기에는 적절하지 않은 함수이다.

## 12. 포인터의 이해
### 12.1 포인터란 무엇인가?
- 포인터를 이용하면 메모리에 직접 접근이 가능하게 된다. 이 때문에 C언어가 Low level 언어의 특성을 지닌다고 알려지게 된 것.
#### 12.1.1 주소 값의 저장을 목적으로 선언되는 포인터 변수
- **포인터 변수** 란 메모리의 주소 값을 저장하기 위한 변수이다!
- 포인터는 '변수 형태의 포인터'와 '상수 형태의 포인터'를 어우르는 표현이지만, 대부분 포인터 변수와 관련되어 있다.

#### 12.1.2 포인터 변수 & 연산자
```javascript
  int main(void) {
    int num = 7;      
    int * pnum;        // 포인터 변수 pnum의 선언
    pnum = &num;      // num의 주소 값을 포인터 변수 pnum에 저장
  }
```
- 포인터 변수의 크기는 4바이트가 될 수도 있고, 8바이트가 될 수도 있다.
  + 32비트 시스템에서는 주소 값을 32비트로 표현하므로 4바이트인 반면, 64비트 시스템에서는 8바이트로 표현.

#### 12.1.3 포인터 변수 선언하기
- 포인터 변수는 가리키고자 하는 변수의 자료형에 따라 선언하는 방법이 달라지지만, `type * ptr; // type형 변수의 주소 값을 저장`
- 사실 주소 값은 동일한 시스템에서 그 크기가 동일하며 모두 정수의 형태를 띤다.
```javascript
  int * pnum1;
  double * pnum2;
  unsigned int * pnum3;
```
- **자료형**: int, char, double 과 같이 변수의 선언 및 구분에 사용되는 키워드
- **포인터 형(type)**: int \*, char \*, double \* 등과 같이 포인터 변수의 선언 및 구분에 사용되는 키워드
- 하지만 포인터 변수도 값을 저장하는 변수이므로 '포인터 형' 역시 '자료형'의 범주에 포함시키기도 한다.
- 포인터에서 **\*의 위치** 는 상관이 없다.
  ```javascript
    double * ptr;
    double* ptr;
    double *ptr;      // 모두 동일한 의미를 갖는다.
  ```

### 12.2 포인터와 관련 있는 연산자: & 연산자와 * 연산자
- 일반적으로 & 연산자와 * 연산자를 가리켜 포인터 연산자라 한다.
- 여기서 * 연산자는 곱셈 연산자(피연산자가 두 개인 이항 연산자)가 아니라 **단항 연산자** 이다.
- & 연산자의 피연산자는 변수이어야 하며, 상수는 피연산자가 될 수 없다.
  `int * pnum = &num;`

#### 12.2.1 포인터가 가리키는 메모리를 참조하는 * 연산자
- \* 연산자는 포인터가 가리키는 메모리 공간에 접근할 때 사용하는 연산자이다.
  ```javascript
    int num = 10;
    int* pnum = &num;
    *pnum = 20;                 // pnum이 가리키는 메모리 공간인 변수 num에 20을 저장
    printf("%d \n", *pnum);
  ```
  즉, \*pnum은 포인터 변수 pnum이 가리키는 변수 num을 의미하는 것이다.

```javascript
  int num1 = 100, num2 = 100;
  int* pnum;

  pnum = &num1;       
  (*pnum) += 30;      // num1 += 30 과 동일한 의미

  pnum = &num2;
  (*pnum) -= 30;      // num2 -= 30 과 동일한 의미

  printf("num1: %d, num2: %d \n", num1, num2);      // num1: 130, num2: 70
```
  + pnum도 변수이기 때문에, 포인터 변수 pnum이 가리키는 대상을 num1에서 num2로 변경 가능

### 12.3 다양한 '포인터 형'이 존재하는 이유
- `return *pnum;`
  + pnum을 int형 포인터 변수라고 가정할 경우
    - pnum이 int형 포인터 변수이므로 pnum에 저장된 주소를 시작으로 4바이트를 읽어 들여서 이를 정수로 해석해야 한다.
  + pnum을 double형 포인터 변수라고 가정할 경우
    - pnum이 double형 포인터 변수이므로 pnum에 저장된 주소를 시작으로 8바이트를 읽어 들여서 이를 실수로 해석해야 한다.
- 이렇듯 **포인터의 형은 메모리 공간을 참조하는 기준이 된다.**

### 12.4 잘못된 포인터의 사용과 널 포인터
- 포인터 변수에는 메모리의 주소 값이 저장되고, 이를 이용해서 해당 메모리 공간에 접근도 가능하기 때문에 상당한 주의가 필요하다.
  + 포인터 변수를 선언만하고 초기화 하지 않을 경우
    ```javascript
      int* ptr;       // 포인터 변수 ptr은 쓰레기 값으로 초기화 된다.
      *ptr = 200;
    ```
    ptr이 가리키는 위치가 어디인줄 알고!!! 만약, ptr이 가리키는 메모리 공간이 매우 중요한 위치였다면, 문제를 일으킬 수 있는 상황!
  + 엉뚱한 값으로 초기화 하는 경우
    ```javascript
      int* ptr = 125;   // 125번지가 어딘 줄 알고?
      *ptr = 10;
    ```
    쓰레기 값으로 포인터 변수를 초기화 한 것과 다르지 않다.
- 그렇다면 포인터 변수는 어떤 값으로 초기화를 시켜야 하나?
  ```javascript
    int* ptr1 = 0;
    int* ptr2 = NULL;   // NULL은 사실상 0을 의미한다.
  ```
  포인터 변수를 우선 선언만 해 놓고, 이후에 유효한 주소 값을 채워 넣을 생각인 경우 위와 같이 초기화 하는 것이 좋다.
  + **널 포인터(Null pointer)**: 여기서 ptr1을 초기화하는 값 0을 가리킨다.
  + 널 포인터는 0번지를 의미하는 것이 아니라, **아무데도 가리키지 않는다** 는 의미
  + 즉, 이를 이용한 * 연산은 메모리 공간에 어떠한 영향도 미치지 않는다.
  + **키워드 NULL은 널 포인터를 의미하며, 실제로 이는 상수 0으로 정의되어 있다.**


## 13. 포인터와 배열! 함께 이해하기
### 13.1 포인터와 배열의 관계
- **배열의 이름도 포인터이다!!!**
#### 13.1.1 배열의 이름은 무엇을 의미하는가?
- 배열의 이름은 포인터이다. 다만, 그 값을 바꿀 수 없는 '상수 형태의 포인터'이다.
  ```javascript
    int arr[3] = {0, 1, 2};
    printf("배열의 이름: %p \n", arr);           // 0012FF50
    printf("첫 번째 요소: %p \n", &arr[0]);      // 0012FF50
    printf("두 번째 요소: %p \n", &arr[1]);      // 0012FF54
    printf("세 번째 요소: %p \n", &arr[2]);      // 0012FF58
  ```
  + `%p`는 주소 값의 출력에 사용되는 서식문자이다.
  + int형 배열요소간 주소 값의 차는 4바이트다.
- **배열의 이름은 배열의 시작 주소 값을 의미하며, 그 형태는 값의 저장이 불가능한 상수이다.** => 배열의 이름을 '포인터 상수'라 한다.
- 포인터 변수는 주소 값의 변경이 가능하지만, 배열의 이름은 주소 값의 변경이 불가능하다! ex.`arr = &arr[1]` 에러 발생
- 배열의 이름도 포인터이므로 **배열의 이름을 피연산자로 하는 * 연산** 이 가능하다!

#### 13.1.2 1차원 배열이름의 포인터 형과 배열이름을 대상으로 하는 * 연산
- `int arr1[5];`
  + 여기서 배열의 이름 arr1이 가리키는 것은 배열의 첫 번째 요소이다.
  + 그런데 배열의 첫 번째 요소가 int형 변수이니 => arr1은 **int형 포인터(int \*)** 라는 것을 알 수 있다.
- 즉, 1차원 배열이름의 포인터 형은 배열의 이름이 가리키는 대상을 기준으로 결정하면 된다!
  ```javascript
    int arr1[3] = {1, 2, 3};
    double arr2[3] = {1.1, 2.2, 3.3};

    *arr1 += 100;
    *arr2 += 120.5;
    printf("%d %g \n", arr1[0], arr2[0]);   // 101 121.6
  ```

#### 13.1.3 포인터를 배열의 이름처럼 사용할 수도 있다.
- 배열의 이름과 포인터 변수는 **상수냐 변수냐의 특성적 차이가 있을 뿐**, 둘 다 포인터이므로 ...
- 포인터 변수로 할 수 있는 연산은 배열의 이름으로도 할 수 있고, 배열의 이름으로 할 수 있는 연산은 포인터 변수로도 할 수 있다.
  ```javascript
    int arr[3] = {15, 25, 35};
    int* ptr = &arr[0];         // int* ptr = arr; 과 동일한 문장

    printf("%d %d \n", ptr[0], arr[0]);     // 15 15
    printf("%d %d \n", ptr[1], arr[1]);     // 25 25
    printf("%d %d \n", ptr[2], arr[2]);     // 35 35
    printf("%d %d \n", *ptr, *arr);         // 15 15
  ```
  위 처럼 포인터 변수를 배열의 이름처럼 사용하는 경우는 거의 없으나, 가능하다는 사실은 알아두기!

### 13.2 포인터 연산
#### 13.2.1 포인터를 대상으로 하는 증가 및 감소연산
- 포인터를 대상으로 메모리의 접근을 위한 * 연산 이외에 증가 및 감소연산도 가능하다.
  ```javascript
    int* ptr1 = 0x0010;       // 부적절한 초기화지만, 연산 결과 확인용!
    double* ptr2 = 0x0010;

    printf("%p %p \n", ptr1 + 1, ptr1 + 2);   // 4 증가, 8 증가   // 00000014 00000018
    printf("%p %p \n", ptr2 + 1, ptr2 + 2);   // 8 증가, 16 증가  // 00000018 00000020

    printf("%p %p \n", ptr1, ptr2);             // 00000010 00000010
    ptr1++;                           // 4 증가 (값 자체도 변함)
    ptr2++;                           // 8 증가 (값 자체도 변함)
    printf("%p %p \n", ptr1, ptr2);             // 00000014 00000018
  ```
  + \+ 연산은 피연산자의 값을 변경시키는 연산이 아니지만, ++ 연산은 포인터 변수에 저장된 값 자체를 변경시키는 연산이다.
  + **int형 포인터를 대상으로 1을 증가시키면 4가 증가하고, double형 포인터를 대상으로 1을 증가시키면 8이 증가한다.**
    - 즉, type형 포인터를 대상으로 n 증가 => **n * sizeof(type)** 의 크기만큼 증가
    - 감소의 경우에도 증가와 동일하다.
- 이러한 포인터의 연산특성으로 인해 다음과 같은 형태의 배열접근이 가능하다.
  ```javascript
    int arr[3] = {11, 22, 33};
    int* ptr = arr;             // int* ptr = &arr[0] 과 동일한 의미
    printf("%d %d %d \n", *ptr, *(ptr + 1), *(ptr + 2));  // 11 22 33

    printf("%d ", *ptr);  ptr++;                          
    printf("%d ", *ptr);  ptr++;                          
    printf("%d ", *ptr);  ptr--;                          
    printf("%d ", *ptr);  ptr--;                          
    printf("%d \n", *ptr);                                // 11 22 33 22 11
  ```
- 다음 두 연산의 차이점은?
  ```javascript
    *(++ptr) = 20;    // ptr에 저장된 값 자체를 변경
    *(ptr+1) = 20;    // ptr에 저장된 값은 변경되지 않음. 결과 값만 얻어냄
  ```
  + 두 문장 모두 현재 ptr이 가리키는 위치에서 4바이트 떨어진 메모리 공간에 20을 저장하는 문장이다.

#### 13.2.2 중요한 결론! arr[i] == \*(arr+i)
```javascript
  int arr[3] = {11, 22, 33};
  int* ptr = arr;

  printf("%d %d %d \n", *(ptr+0), *(ptr+1), *(ptr+2));      // *(ptr+0)은 *ptr과 동일
  printf("%d %d %d \n", ptr[0], ptr[1], ptr[2]);
  printf("%d %d %d \n", *(arr+0), *(arr+1), *(arr+2));      // *(arr+0)은 *arr과 동일
  printf("%d %d %d \n", arr[0], arr[1], arr[2]);
```
- 위의 예제는 네 문장 모두 동일한 출력결과를 보인다. 즉, `arr[i] == *(arr+i)`

### 13.3 상수 형태의 문자열을 가리키는 포인터
- 마지막에 널 문자가 삽입되는 문자열의 선언방식에는 두 가지가 있다.
  + 배열을 이용하는 방식
    `char str1[] = "My String";`
    - str1은 그 자체로 문자열 전체를 저장하는 배열
  + char형 포인터 변수를 이용하는 방식
    `char* str2 = "Your String";`
    - str2는 메모리상에 자동으로 저장된 문자열 "Your String"의 첫 번째 문자를 단순히 가리키고만 있는 포인터 변수
  + str1도 실제로는 문자 'M'의 주소 값이기 때문에 str1도 str2도 문자열의 시작 주소 값을 담고 있다는 측면에서는 동일하다.
  + 다만, **str1은 계속해서 문자 M이 저장된 위치를 가리키는 상태이어야 하지만, 포인터 변수 str2는 다른 위치를 가리킬 수 있다.**
    ```javascript
      char* str = "Your Team";
      str = "Our Team";       // str이 가리키는 대상을 문자열 "Our Team"으로 변경할 수 있음
    ```
    str1의 경우 상수형태의 포인터이므로 위와 같이 가리키는 대상 변경이 불가능!!
  + 배열을 대상으로한 값의 변경
    ```c
      char str1[] = "My String";      // 변수 형태의 문자열
      char* str2 = "Your String";     // 상수 형태의 문자열. 배열을 대상으로 값 변경 불가

      str2 = "Our String";            // 가리키는 대상 변경

      str1[0] = 'X';                  // 문자열 변경 성공!
      str2[0] = 'X';                  // 문자열 변경 실패! 에러 발생!
    ```
- 어디서든 선언할 수 있는 상수 형태의 문자열
  + `char* str = "Const String";` => 상수 형태의 문자열
    - 먼저 문자열이 메모리 공간에 저장된 후, 그 메모리의 주소 값이 반환된다.
    - 즉, 문자열 저장 이후 `char* str = 0x1234;` 다음과 같은 형태가 되므로 문자열의 주소 값이 str에 저장되는 것이다.
  + `printf("Show your string");`
    - 이와 같은 경우에도 큰따옴표로 묶여서 표현되는 문자열은 그 형태에 상관없이 메모리 공간에 저장된 후 그 주소값이 반환된다.
    - `printf(0x1234);` => printf 함수는 문자열을 통째로 전달받는 함수가 아닌, 문자열의 주소 값을 전달받는 함수이다.
    - ex.
      ```c
        WhoAreYou("Hong");  // WhoAreYou라는 함수호출 (실제 전달 값은 문자 H의 주소값이므로 반환형은 void라 가정)
        void WhoAreYou(char * str) {...}
      ```

### 13.4 포인터 변수로 이뤄진 배열: 포인터 배열
- 지금까지는 기본 자료형의 변수를 요소로 지니는 배열만 선언했으나, 포인터 변수도 변수이니 이를 대상으로 배열을 선언할 수 있다!
#### 13.4.1 포인터 배열의 이해
- **포인터 배열**: 포인터 변수로 이루어져 주소 값의 저장이 가능한 배열
  ```c
    int* arr1[20];      // 길이가 20인 int형 포인터 배열 arr1
    double* arr2[30];   // 길이가 30인 double형 포인터 배열 arr2
  ```
- 포인터 배열의 선언과 활용
  ```c
    int num1 = 10, num2 = 20, num3 = 30;
    int* arr[3] = {&num1, &num2, &num3};

    printf("%d \n", *arr[0]);     // 10
    printf("%d \n", *arr[1]);     // 20
    printf("%d \n", *arr[2]);     // 30
  ```
- 문자열을 저장하는 포인터 배열
  + **문자열 배열**: 문자열의 주소 값을 저장할 수 있는 배열. (= char형 포인터 배열)
  + `char* strArr[3];` => char형 포인터 배열은 문자열의 주소 값을 저장할 수 있어 문자열 배열로 불린다.
    ```c
      char* strArr[3] = {"Simple", "String", "Array"};
      printf("%s \n", strArr[0]);     // Simple
      printf("%s \n", strArr[1]);     // String
      printf("%s \n", strArr[2]);     // Array
    ```
    - **큰따옴표로 묶여서 표현되는 문자열은 그 형태에 상관없이 메모리 공간에 저장된 후 그 주소 값이 반환된다.**
    - 즉, `char* strArr[3] = {0x1004, 0x1048, 0x2012};` => 문자열이 저장된 이후에는 다음의 형태가 된다.

## 14. 포인터와 함수에 대한 이해
### 14.1 함수의 인자로 배열 전달하기
#### 14.1.1 인자전달의 기본방식은 값의 복사이다!
- 함수호출 시 전달되는 인자의 값은 매개변수에 복사가 된다.
  ```c
    int SimpleFunc(int num) {...}
    int main(void) {
      int age = 17;
      SimpleFunc(age);    // age에 저장된 값이 매개변수 num에 복사된다.
    }
  ```
  + 여기서 실제로 전달되는 것은 age가 아니라, age에 저장된 값이다!
  + 그러므로, SimpleFunc 함수 내에서 num값이 증가되더라도 age의 값은 변하지 않는다.
- 그렇다면, 함수호출 시 인자로 배열을 통째로 전달할 수는 없을까?
  + 없다. 함수를 호출하면서 매개변수에 배열을 통째로 넘겨주는 방법은 존재하지 않는다.
  + 왜? **배열을 통째로 넘겨받으려면 매개변수로 배열을 선언할 수 있어야 하기 때문이다.** => 불가능
  + 대신에 함수 내에서 배열에 접근할 수 있도록 배열의 주소 값을 전달하는 것은 가능하다.

#### 14.1.2 배열을 함수의 인자로 전달하는 방식
- 아파트를 보고 싶어 하는 사람 앞에 아파트를 통째로 복사해다 놓을 수 없다면, 아파트의 주소를 가르쳐줘서 직접 찾아가게 하면 된다.
- 이처럼 배열을 통째로 전달하는 것이 불가능하다면, 배열의 주소 값을 인자로 전달해서 이를 통해 접근하도록 유도하는 방법
  ```c
    int arr[3] = {1, 2, 3};
    SimpleFunc(arr);    // SimpleFunc 함수를 호출하면서 배열 arr의 주소 값 전달
  ```
  + SimpleFunc 함수의 매개변수 선언 => `void SimpleFunc(int* param) {...}`
  + 이렇게 전달된 param을 이용해서 배열의 형태로 접근하기
    `printf("%d %d", param[1], param[2]);`
  + **주소 값만 알면 해당 메모리 공간에 접근이 가능하므로** 값의 출력 뿐만 아니라, 값의 변경 또한 가능하다.
- **배열의 주소 값만 안다면 어디서든 배열에 접근하여 저장된 값을 참조하고 변경할 수 있다.**

#### 14.1.3 배열을 함수의 인자로 전달받는 함수의 또 다른 선언
```c
  void ShowArayElem(int* param, int len) {...}

  void ShowArayElem(int param[], int len) {...}
```
- `int* param`과 `int param[]`은 완전히 동일한 선언이다.
- `int param[]`과 같은 형태가 배열이 인자로 전달된다는 느낌을 강하게 주기 때문에, 배열의 주소 값이 전달될 때 많이 사용된다.
- 그러나, 위의 두 선언이 동일하게 간주되는 경우는 **매개변수의 선언으로 제한** 된다.
  + `int* ptr = arr;    // int ptr[] = arr;로 대체 불가능`
- 함수 내에서는 인자로 전달된 배열의 길이 계산 불가
  ```c
    void SimpleAryFunc1(int* arr) {
      int sz = sizeof(arr);   // 변수 sz에는 포인터 변수 arr의 크기가 저장
      ...
    }

    void SimpleAryFunc2(int arr[]) {
      int sz = sizeof(arr);   // 변수 sz에는 포인터 변수 arr의 크기가 저장
    }
  ```
  + 배열의 주소 값을 인자로 전달받는 매개변수는 포인터 변수이므로 배열의 크기가 반환되지 않고 포인터 변수의 크기가 반환된다.
  + 그러므로, 함수 내에서는 배열의 길이를 계산할 수 없으므로 배열의 크기나 길이정보도 함께 인자로 전달해야 한다.

### 14.2 Call-by-value vs Call-by-reference
- 함수를 호출할 때 단순히 값을 전달하는 형태의 함수호출을 Call-by-value,
- 메모리의 접근에 사용되는 주소 값을 전달하는 형태의 함수호출을 Call-by-reference라 한다.
- 즉, Call-by-value와 Call-by-reference를 구분하는 기준은 함수의 인자로 전달되는 대상에 있다.
#### 14.2.1 값을 전달하는 형태의 함수호출: Call-by-value
  ```javascript
    void SwapChange(int n1, int n2) {...}

    int main(void) {
      int num1 = 10, num2 = 20;
      SwapChange(num1, num2);       // SwapChange 함수 호출을 통해 두 값이 서로 바뀌길 기대
      printf("num1 num2: %d %d\n", num1, num2);   // 바뀌지 않고 그대로 10 20 출력됨
    }
  ```
  + SwapChange 함수 호출을 통해 num1과 num2의 값이 뒤바뀌길 기대하지만, 실제 num1과 num2의 값은 그대로임
#### 14.2.2 주소 값을 전달하는 형태의 함수호출: Call-by-reference
- 위의 예제에서 SwapChange 함수 내에서 num1과 num2에 직접 접근이 가능하도록 하면 두 값을 바꿀 수 있다.
  ```javascript
    void SwapChange(int* ptr1, int* ptr2) {
      int temp = *ptr1;
      *ptr1 = *ptr2;
      *ptr2 = temp;
    }

    int main(void) {
      SwapChange(&num1, &num2);
    }
  ```
#### 이제는 scanf 함수호출 시 & 연산자를 붙이는 이유를 알 수 있다.
  ```javascript
    int main(void) {
      int num;
      scanf("%d", &num);      // 변수 num의 주소 값을 scanf 함수에 전달
    }
  ```
  + 위의 scanf 함수호출이 완료되면 변수 num에는 값이 채워진다.
  + 즉, 사용자로부터 값을 입력받아서 num에 그 값을 채우는 일은 scanf가 담당하므로 scanf 함수는 num의 주소 값을 알아야 한다.
  + 그래야 num에 접근을 해서 값을 채워 넣을 수 있기 때문이다.
- 즉, scanf 함수의 호출도 Call-by-reference 형태의 함수호출에 해당한다.
- 그렇다면 문자열을 입력 받을 때에는 왜 & 연산자를 붙이지 않는 것일까?
  ```javascript
    char str[30];
    scanf("%s", str);     // scanf("%s", &str)은 틀린 표현
  ```
### 14.3 포인터 대상의 const 선언
#### 14.3.1 포인터 변수가 참조하는 대상의 변경을 허용하지 않는 const 선언
```javascript
  int num = 20;
  const int* ptr = &num;
  *ptr = 30;    // 컴파일 에러!
  num = 40;     // 컴파일 성공!
```
- const가 붙으면 포인터 변수 ptr을 이용해서 ptr이 가리키는 변수에 저장된 값을 변경하는 것을 허용하지 않겠다는 뜻
- const를 사용한다고 해서 포인터 변수 ptr이 가리키는 변수 num이 상수화되는 것은 아니다. `num = 40;`은 허용됨
- 값을 변경하는 방법에 제한을 두는 것일 뿐, 상수로 만드는 선언은 아니다.
#### 14.3.2 포인터 변수의 상수화
- const 선언은 포인터 변수의 이름 앞에 올 수도 있다.
- `int* const ptr = &num;`
- 이렇게 되면, 포인터 변수 ptr은 상수가 되며 한번 주소 값이 저장되면 그 값의 변경이 불가능하다.
  ```javascript
    int num1 = 20, num2 = 30;
    int* const ptr = &num1;
    ptr = &num2;      // 컴파일 에러!
    *ptr = 40;        // 컴파일 성공!
  ```
  + ptr만 상수일 뿐, ptr이 가리키는 대상에 저장된 값을 변경하는 연산은 문제가 되지 않는다.
- 두 가지 형태의 const 동시 선언
  + `const int* const ptr = &num;`
    ```javascript
      *ptr = 20;
      ptr = &age;         // 둘 다 컴파일 에러!
    ```
#### 14.3.3 const 선언이 갖는 의미
- const는 원래 C++에만 존재하던 키워드였는데 C언어의 표준 재정립 과정에서 추가됨
- const 선언을 많이 하면 프로그램 코드의 안정성이 높아진다.
  ```javascript
    double PI = 3.1415;
    PI = 3.07;          // 실수로 삽입된 문장, 컴파일 시 발견 안됨

    ...

    const double PI = 3.1415;
    PI = 3.07;          // 컴파일 시 발견되는 오류상황
  ```
  사소해 보일 수 있으나, 컴파일러가 이러한 문제점을 발견하지 못할 경우 오류를 찾기 쉽지 않다.
