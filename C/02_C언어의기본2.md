# C언어의 기본2
## 6. printf 함수와 scanf 함수 정리하기
### 6.1 특수문자의 출력이 필요한 이유
- printf 함수 내에서 큰 따옴표의 시작과 끝을 문자열의 시작과 끝으로 인식한다.
- 문자열의 일부로 큰 따옴표를 포함시키려면?
  + **특수문자** 혹은 **이스케이프 시퀀스(escape sequence)** 사용하기
  + 큰 따옴표 앞에 특수문자 `\`를 붙여주면 큰 따옴표 자체 출력이 가능하다.
  + ex. `printf("앞집 강아지가 말했다. \"멍~! 멍~!\" 정말 커엽다.")`

### 6.2 특수문자의 종류
- `\a` 경고음
- `\b` 백스페이스(backspace)
- `\f` 폼 피드(form feed)
- `\n` 개 행(new line)
- `\r` 캐리지 리턴(carriage return)
- `\t` 수평 탭
- `\v` 수직 탭
- `\'` 작은 따옴표 출력
- `\"` 큰 따옴표 출력
- `\?` 물음표 출력
- `\\` 역슬래쉬 출력
- `\f`, `\v`는 모니터 출력이 아닌 프린터 출력을 위해 정의된 특수문자. 모니터 출력에서는 별 의미가 없다.

### 6.3 printf 함수의 서식지정
- `%d`는 데이터를 10진수 정수의 형태로 출력한다는 의미
- `%X`는 데이터를 16진수로 출력하되, 알파벳은 대문자로 출력한다는 의미. `%x`는 소문자.

### 6.4 서식문자의 종류와 그 의미
- `%d`: char, short, int => 부호 있는 10진수 정수
- `%ld`: long => 부호 있는 10진수 정수
- `%lld`: long long => 부호 있는 10진수 정수
- `%u`: unsigned int => 부호 없는 10진수 정수
- `%o`: unsigned int => 부호 없는 8진수 정수
- `%X`, `%x`: unsigned int => 부호 없는 16진수 정수
- `%f`: float, double => 10진수 방식의 부동소수점 실수
- `%Lf`: long double => 10진수 방식의 부동소수점 실수
- `%e`, `%E`: float, double => e또는 E방식의 부동소수점 실수, 소문자와 대문자 차이
- `%g`, `%G`: float, double => 값에 따라 %f와 %e 사이에서 선택, e 표기를 소문자,대문자로 차이
- `%c`: char, short, int => 값에 대응하는 문자
- `%s`: char * => 문자열
- `%p`: void * => 포인터의 주소 값
#### 6.4.1 정수의 출력을 위한 서식문자들 : %d, %u, %o, %x
- %o, %x를 이용해서는 8진수와 16진수의 양의 정수만 출력이 가능하다.
- 그러므로 음의 정수를 출력하려면 반드시 `%d`를 사용해야 한다.
- 8진수와 16진수는 음의 정수 표현에 거의 사용되지 않는 표현법이므로 서식문자에서도 양의 정수만 출력하도록 제한하고 있다.
- 8진수를 8진수답게, 16진수를 16진수답게 출력하려면, 서식문자 %o, %x의 사이에 문자 #을 넣어서 `%#o`, `%#x`를 사용하면 된다.
```
  int num1 = 7, num2 = 13;
  printf("%o %#o \n", num1, num1);      // 7  07
  printf("%x %#x \n", num2, num2);      // d  0xd
```
- 이처럼 16진수로 출력할 경우 출력된 내용이 16진수 정보임을 알리기 위해 가급적이면 **#** 을 사용하는 것이 좋다.

#### 6.4.2 실수의 출력을 위한 서식문자들: %f, %e, %g
```
  printf("%f \n", 0.1234);          // 0.123400
  printf("%e \n", 0.1234);          // 1.234000e-001  // e표기법 기반
  printf("%f \n", 0.12345678);      // 0.123457
  printf("%e \n", 0.12345678);      // 1.234568e-001  // e표기법 기반
```
- **e 표기법**
  + 0.00000000000000000001
  + = 1.0 * 10^(-20)
  + 그러나, 프로그램 상에서는 지수를 표현할 수 없기 때문에,
  + = 1.0e-20 으로 표기한다.
```
  double d1 = 1.23e-3;      // %f 스타일 출력  // 0.00123
  double d2 = 1.23e-4;      // %f 스타일 출력  // 0.000123
  double d3 = 1.23e-5;      // %e 스타일 출력  // 1.23e-005
  double d4 = 1.23e-6;      // %e 스타일 출력  // 1.23e-006
```
- **%g는 소수점 이하의 자릿수가 늘어나면 e 표기법으로 출력을 하는구나!**
- 서식문자 `%g`는 실수의 형태에 따라서 %f와 %e 사이에서 적절한 형태의 출력을 진행한다.
- **%s는 문자열을 출력하는데 사용된다!**

#### 6.4.3 필드 폭을 지정하여 정돈된 출력 보이기
- 보기 좋은 출력을 위해서 필드의 폭을 지정하는 것이 필요하다.
- `%8d`: 필드 폭을 8칸 확보하고, 오른쪽 정렬해서 출력을 진행한다.
- `%-8d`: 필드 폭을 8칸 확보하고, 왼쪽 정렬해서 출력을 진행한다.

### 6.5 scanf 함수
- scanf 함수의 호출을 위해서는 입력의 **형식** 과 입력의 **장소** 정보가 전달되어야 한다.
- printf 함수에서는 %f, %e, %g의 의미가 각각 다르지만,
- scanf 함수에서는 **float 형 데이터를 입력 받겠다** 는 동일한 의미를 담고 있다.
- `%lf`: double. %f에 l이 추가된 형태
- `%Lf`: long double. %f에 L이 추가된 형태
- 실수를 입력할 때 e 표기법을 사용해도 된다.
- **float, double, long double의 데이터 출력에 사용되는 서식문자는 각각 %f, %f, %Lf이다.**
- **float, double, long double의 데이터 입력에 사용되는 서식문자는 각각 %f, %lf, %Lf이다.**


## 7. 반복실행을 명령하는 반복문
- 반복문의 구성에 있어서 가장 중요한 것은 **반복의 조건을 무너뜨리기 위한 최소한의 연산** 이다.
### 7.1 while문에 의한 문장의 반복
```
  while(num < 3) {        // 반복의 조건은 num < 3
    printf("Hello World! \n");
    num++;
  }
```
- 반복의 대상이 하나의 문장이라면 중괄호는 생략 가능하다.
  ```
    while(num < 5)
      printf("Hello World! %d \n", num++);
  ```
  ```
    while(num < 5)
      printf("Hello World! %d \n", num), num++;
  ```
- 그러나 코드의 라인수가 줄어든다고 무조건 좋은 것은 아니므로 억지로 코드를 줄이는 것은 바람직하지 못하다.
- 무한루프의 구성
  ```
    while(1) {
      printf("Hello World! \n");
    }
  ```
  + 숫자 1은 '참'을 의미하는 대표값이다.
  + 무한루프는 프로그래머의 실수로 만들어지는 것이 아니라, 필요에 의해 만들어지기도 한다.
- while문 두 개를 사용하여 중첩 사용할 수 있다. (ex. 구구단)

### 7.2 do~while문에 의한 문장의 반복
- while문과의 가장 큰 차이점은 **반복의 조건을 검사하는 시점** 에 있다!
- do~while문의 경우 while문과 달리 '반복조건'을 뒷부분에서 검사한다.
- **do~while문은 반복영역을 최소한 한번은 실행하는 구조** 이다. (선실행 후검사)
```
  do {
    printf("Hello World! \n");
    num++;
  } while(num < 3);
```
- while문의 경우, 반복의 조건이 앞 부분에 위치하므로 코드 작성 시에도, 이해하기에도 용이하다.
- 그럼, do~while문은 언제쓰는가?
  + 반복영역이 무조건 한 번 이상 실행되어야 하는 경우!
  ```
    #include <stdio.h>
    int main(void) {
      int total = 0, num = 0;

      do {
        printf("정수 입력(0 to quit): ");
        scanf("%d", &num);
        total += num;
      } while(num != 0);

      printf("합계: %d \n", total);
      return 0;
    }
  ```
  + 사용자로부터 하나의 정수를 입력 받고 난 다음에야 비로소 진행할지 여부를 결정하므로...
  + 반복영역을 최소한 한번은 실행해야 한다. 이런 경우에는 while문 보다 do~while문이 자연스럽다.
  ```
    정수 입력(0 to quit): 1
    정수 입력(0 to quit): 2
    정수 입력(0 to quit): 3
    정수 입력(0 to quit): 4
    정수 입력(0 to quit): 5
    정수 입력(0 to quit): 0
    합계: 15    
  ```

### 7.3 for문에 의한 문장의 반복
- **for문은 반복문 중에서 가장 많이 사용된다.**
- for문은 반복을 구성하기 위해 필요한 모든 것을 한데 묶을 수 있도록 만들어진 반복문이다.
```
  for ( 초기식 ; 조건식 ; 증감식) {
    // 반복의 대상이 되는 문장들
  }
```
- while문보다 코드가 간결하다!
```
  int main(void) {
    for (int num = 0; num < 3; num++) {
      printf("Hi~");
    }
  }
```
- 아직도 일부 C 컴파일러는 for문의 '초기식' 위치에서의 변수선언을 허용하지 않고 있다. (최근 표준에서는 허용)
```
  int num;      // 이와 같이 작성해야 모든 C 컴파일러에서 컴파일이 가능하다.
  for (num = 0; num < 3; num++)
```
- for문의 실행 순서
  + 초기식: 본격적으로 반복을 시작하기에 앞서 딱 한번 실행된다.
  + 조건식: 매 반복의 시작에 앞서 실행되며, 그 결과를 기반으로 반복유무를 결정!
  + 증감식: 매 반복실행 후 마지막에 연산이 이뤄진다.
  ```
    //      1           2       4
    for (int num = 0; num < 3; num++) {
      printf("Hi~! \n");    // 3
    }
  ```
  + 첫 번째 반복의 흐름: 1-2-3-4 [num=1]
  + 두 번째 반복의 흐름: 2-3-4 [num=2]
  + 세 번째 반복의 흐름: 2-3-4 [num=3]
  + 네 번째 반복의 흐름: 2 [num=3] 따라서 탈출!
- **for문 vs while문**
  + 반복의 횟수가 딱 정해진 경우라면 for문이 최선이지만,
  + 예를 들어, 사용자로부터 임의의 값 입력을 기다리는 상황이라면, while문이 더 자연스러울 수 있다.
- for문의 초기식과 증감식은 불필요한 경우 비워도 된다. ex. `for( ;input > 0; )`
- for문을 이용한 무한루프 생성
```
  for( ; ; ) {
    ...     // for문의 중간에 위치한 '조건식'이 비워질경우 무조건 '참'으로 인식되어 무한루프 형성됨
  }
```

## 8. 조건에 따른 흐름의 분기
### 8.1 if문을 이용한 조건적 실행
#### 8.1.1 if~else문을 이용한 흐름의 분기
- 조건을 만족하는 if문이 발견되면 필요없는 나머지 if문은 건너뛰기 위해!
#### 8.1.2 if...else if...else의 구성
- 셋 이상의 블록 중 하나를 선택해서 실행하는 구조이다.
```
  if (조건 1) {
    // 조건 1 만족 시 실행
  } else if (조건 2) {
    // 조건 2 만족 시 실행
  } else if (조건 3) {
    // 조건 3 만족 시 실행
  } else {
    // 모두 불 만족 시 실행
  }
```
- 하나라도 조건이 만족되어 해당 블록을 실행하고 나면, **마지막에 있는 else** 까지도 그냥 건너뛴다.
- **if...else if...else는 if~else를 중첩시킨 형태에 지나지 않는다!**
  ```
    if (num < 0) {
      printf("입력 값은 0보다 작다. \n");
    } else if (num > 0) {
      printf("입력 값은 0보다 크다. \n");
    } else {
      printf("입력 값은 0이다. \n");
    }
  ```
  ```
    if (num < 0) {
      printf("입력 값은 0보다 작다. \n");
    } else {
      if (num > 0) {
        printf("입력 값은 0보다 크다. \n");
      } else {
        printf("입력 값은 0이다. \n");
      }
    }
  ```
  + 즉, if...else if... else는 if~else문을 중첩시키되 else 블록을 대상으로 중첩시킨 결과!
  + 그래서 if문에 명시된 하나의 조건이 '참'이 되면, 나머지를 건너 뛰었던 것이다.
#### 8.1.3 조건 연산자: 피 연산자가 세 개인 '삼 항 연산자'
`(조건) ? (data1) : (data2)`
- 위 문장에서 조건이 '참'이면 data1이 반환되고, '거짓'이면 data2가 반환된다.
- ex. `int num3 = (num1 > num2) ? (num1) : (num2);`
  + 조건이 '참'일 경우, `int num3 = num1`
  + 조건이 '거짓'일 경우, `int num3 = num2`

### 8.2 반복문의 생략과 탈출: continue & break
#### 8.2.1 break! 이제 그만 빠져나가자!
- break는 반복문을 탈출 할 때 (빠져 나올 때) 사용하는 키워드
- break문을 가장 가까이서 감싸고 있는 **반복문** 하나를 빠져 나오게 된다.
- **break문이 if문과 함께 쓰였다고 해서 if문을 빠져 나오는 것으로 오해하면 안 된다.**

#### 8.2.2 continue! 나머지 생략하고 반복 조건 확인하러 가자!
- break문과 마찬가지로 반복문 안에 삽입된다.
- continue를 실행하게 되면, 실행중인 위치에 상관없이 반복문의 조건검사 위치로 이동한다.

### 8.3 switch문에 의한 선택적 실행과 goto문
- switch문은 if...else if...else와 유사하지만, 사용할 수 있는 영역은 제한적이다.
```
  switch(num) {
    case 1:
      printf("1은 ONE \n");
      break;
    case 2:
      printf("2는 TWO \n");
      break;
    default:
      printf("I don't know! \n");
  }
```
- `switch(n)`에서의 n은 정수형 변수이어야 하는데 (이 정수형 변수에는 char형도 포함),
- 대표적으로는 int형 변수가 위치하게 된다.
- **n에 저장된 값에 따라서 실행할 영역이 결정된다.**
- case문은 위치를 표시하는데 사용되므로 **레이블(label)** 이라 한다.
- default는 일치하는 case 레이블이 없을 때 실행되는데 **생략 가능** 하다.
- **case문에서 break를 설정하지 않을 경우 이후의 레이블을 모두 실행하게 된다!**
#### 8.3.1 break문을 생략한 형태의 switch문 구성
- 해당 case문만 실행되도록 동작방식을 결정해 놓으면 break를 일일이 붙이는 수고를 덜 수 있지 않을까?
```
  switch(sel) {
    case 'M':
    case 'm':
      printf("Morning! \n");
      break;
    case 'A':
    case 'a':
      printf("Afternoon! \n");
      break;
    case 'E':
    case 'e':
      printf("Evening! \n");
      break;        // 사실 불필요한 break문!
  }
```
- 대문자 M이 아닌 소문자 m을 입력해도 `Morning!`이 출력된다!
- **break문이 삽입되어 유용한 경우도 있지만, 삽입되지 않아 유용한 경우도 있다!**
#### 8.3.2 switch vs if...else if...else 비교
- 분기의 수가 많아질 경우 가급적 switch문으로 구현을 한다!
- switch문으로 구현할 수 있는 조건의 구성에는 한계가 존재한다! 이럴 땐 if...else if...else!
  ```
    if (n >= 0 && n < 10) {
      printf("0이상 10미만! \n");
    } else if (n >= 10 && n < 20) {
      printf("10이상 20미만! \n");
    } else {
      printf("20이상 \n");
    }
  ```
#### 8.3.3 goto 키워드
- goto는 이름이 의미하듯이 프로그램의 흐름을 원하는 위치로 이동시킬 때 사용하는 키워드이다.
- 근래에 출간되는 C언어 서적 중에는 goto를 아예 언급조차 하지 않는 서적도 있다.
- **goto의 단점**
  + 프로그램의 자연스러운 흐름을 방해한다.
- C언어와 같은 절차지향 프로그래밍 언어에서 프로그램의 흐름을 방해하거나 복잡하게 하는 것은 아주 큰 단점
- goto문을 써야만 해결할 수 있는 문제의 상황도 제한적이며 설득력이 강하지도 않다.
- 그래서 **goto문의 사용을 가급적 자제하거나 아예 사용하지 말자고 결론을 내리게 되었다.**
- 기본 구성
  ```
    int main(void) {
      ....
    rabbit:         // 위치지정에 사용된 rabbit이라는 이름의 레이블
      ....
      goto rabbit:  // 레이블 rabbit의 위치로 이동!
      ....
    }
  ```
- goto문 ex.
```
  int main(void) {
    if (num == 1) {
      goto ONE;
    } else if (num ==2) {
      goto TWO;
    } else {
      goto OTHER;
    }

  ONE:
    printf("1을 입력하셨습니다! \n");
    goto END;
  TWO:
    printf("2를 입력하셨습니다! \n");
    goto END;
  OTHER:
    printf("3 혹은 다른 값을 입력하셨군요. \n");

  END:
    return 0;
  }
```

## 9. C언어의 핵심! 함수!
- 함수를 만드는 이유
  + 크고 복잡한 문제를 작게 나눠서 해결해 나가는 것이 보다 빠르게, 정확히 문제를 해결하는 원칙이 된다!
  + **Divide and Conquer!!!**
  + 프로그램을 작은 크기의 함수들로 나눠서 구현하게 되면, 문제의 발생 및 프로그램의 요구사항 변경이 필요한 경우에 변경의 범위를 축소 및 제한할 수 있다.
- C언어의 함수는 전달인자가 없거나 반환 값이 없는 경우도 있다.
  + printf 함수도 실제로는 값을 반환한다.
  ```
    num1 = printf("12345\n");
    num2 = printf("I love my home\n");
    printf("%d %d \n", num1, num2);       // 6 15
    return 0;
  ```
  + printf 함수는 `\n` 문자를 포함하여 모니터에 출력한 문자열의 길이를 반환한다.
    - 한글의 경우, 운영체제에 따라 다르게 표현될 수 있다.
    - Windows는 한글을 한 글자당 2바이트로 표현한다.
- **함수호출 시 전달할 수 있는 인자의 수는 여러 개가 될 수 있지만, 반환할 수 있는 값의 수는 하나이다!**
- 함수의 유형 4가지
  + 유형 1: 전달인자 O , 반환 값 O
    ```
      int Add(int num1, int num2) {
        return num1 + num2;
      }
    ```
  + 유형 2: 전달인자 O , 반환 값 X
    ```
      void ShowAddResult(int num) {
        printf("덧셈결과 출력: %d \n", num);
      }
    ```
    - printf 함수는 매번 서식을 지정해야 하므로 위와 같이 printf를 대체할 수 있는 함수 구현 가능
  + 유형 3: 전달인자 X , 반환 값 O
    ```
      int ReadNum(void) {
        int num;
        scanf("%d", &num);
        return num;
      }
    ```
    - 위와 같은 경우, 사용자로부터 정수를 입력 받을 때 scanf 함수보다 편리하게 입력 받을 수 있다.
    - 여기서 void는 '인자를 전달하지 않는다'라는 뜻이므로 함수 호출 시 인자를 전달하면 안 된다.
  + 유형 4: 전달인자 X , 반환 값 X
    ```
      void HowToUseThisProg(void) {
        printf("두 개의 정수를 입력하시면 덧셈결과가 출력됩니다! \n");
        printf("자! 그럼 두 개의 정수를 입력하세요. \n");
      }
    ```
- return이 지니는 두 가지 의미 중 한가지 의미만 살리기
  + 키워드 return이 가지는 의미
    - 함수를 빠져나간다.
    - 값을 반환한다.
  + 반환형이 void로 선언된 함수에서도 return문을 사용할 수 있다!
    ```
      void NoReturnType(int num) {
        if (num < 0)
          return;       // 값을 반환하지 않는 return문!
      }
    ```
    - **값의 반환 없이 그냥 함수를 빠져나간다!** 는 의미
### 9.1 함수의 정의와 그에 따른 원형의 선언
- 함수는 호출되기 이전에 미리 정의되어야 한다!
  ```
    int Increment(int n) {
      n++;
      return n;
    }

    int main(void) {
      int num = 2;
      num = Increment(num);     // 앞서 본 함수
      return 0;
    }
  ```
- 혹은
  ```
    int Increment(int n);       // 함수의 선언

    int main(void) {
      int num = 2;
      num = Increment(num);
      return 0;
    }

    int Increment(int n) {      // 함수의 정의
      n++;
      return n;
    }
  ```
  + 이렇게 함수의 선언을 미리 해주면 Increment함수의 정의가 main함수 뒤에 와도 에러가 발생하지 않는다.
  + 함수의 선언에는 매개변수의 갯수 및 자료형 정보만 포함되면 되기 때문에 매개변수의 이름 생략 가능하다.
    ```
      int Increment(int);
    ```
### 9.2 변수의 존재기간과 접근범위 1: 지역변수
#### 9.2.1 함수 내에만 존재 및 접근 가능한 지역변수 (Local Variable)
- '지역변수'에서 말하는 지역이란 중괄호에 의해 형성되는 영역을 뜻한다.
- 따라서, 중괄호 내에서 선언되는 변수는 모두 지역변수다.
- 지역변수는 해당지역을 벗어나면 자동으로 소멸된다.
- **지역변수는 선언된 지역 내에서만 유효하기 때문에 선언된 지역이 다르면 이름이 같아도 문제되지 않는다.**
- 지역변수는 **스택(Stack)** 메모리 영역에 할당된다.
  + 지역변수는 해당 선언문이 실행될 때 메모리 공간에 할당되었다가, 선언문이 존재하는 함수가 반환을 하면 (종료를 하면) 메모리 공간에서 소멸된다.
- 지역변수는 외부에 선언된 동일한 이름의 변수를 가리게 된다.
- 함수를 정의할 때 선언하는 매개변수도 지역변수의 일종이다.
  + 매개변수는 지역변수이다! (O)
  + 지역변수는 매개변수이다! (X) <- 모든 지역변수가 매개변수는 아니기 때문이다.
- 자동변수 (automatic variable)
  + 지역변수를 가리켜 '자동변수'라고도 한다. 선언된 영역을 벗어나면 자동으로 소멸되므로 ...

### 9.3 변수의 존재기간과 접근범위 2: 전역변수, static 변수, register 변수
#### 9.3.1 전역변수 (Global Variable)
  ```
    #include <stdio.h>
    int num;            // 전역변수는 기본 0으로 초기화 된다.

    int main(void) {    // main함수
      .....
    }
  ```
- 전역변수의 특징
  + 프로그램의 시작과 동시에 메모리 공간에 할당되어 종료 시까지 존재한다.
  + 별도의 값으로 초기화하지 않으면 0으로 초기화된다.
  + 프로그램 전체 영역 어디서든 접근이 가능하다.
- 동일한 이름의 전역변수와 지역변수가 있을 경우, 전역변수가 가리워지므로, 두 변수의 이름을 달리하는 것이 좋다.
- 전역변수의 남용은 프로그램을 복잡하게 만드는 주범이다!
- **스파게티 코드(Spaghetti Code)**: 전역변수의 과도한 선언과 같은 잘못된 프로그래밍 방식에 의해서 생성된 얽히고 설킨 코드를 가리킨다.

#### 9.3.2 지역변수에 static 선언을 추가해서 만드는 static 변수
- 전역변수와 지역변수 모두에 static 선언을 추가할 수 있다.
- static이 선언된 함수가 호출 되었을 때 선언이 되는게 아니라, **프로그램 시작과 동시에 할당 및 초기화 된다.**
- 단, 지역변수와 마찬가지로 선언된 함수 내에서만 접근이 가능하다.
- **지역변수에 static 선언을 붙이게 되면 전역변수의 성격을 지니는 변수가 된다.**
  + 지역변수의 특성
    - 선언된 함수 내에서만 접근이 가능하다.
    - 함수 내에 선언된 지역변수는 해당 함수가 반환하면 소멸된다.
  + static 선언이 붙은 지역변수의 특성
    - 선언된 함수 내에서만 접근이 가능하다.
    - 딱 1회 초기화되고, 프로그램 종료 시까지 메모리 공간에 존재한다. (전역변수 특성)
    ```
      static int num1 = 0;      // 초기화하지 않으면 0으로 초기화 된다.
      int num2 = 0;             // 초기화하지 않으면 쓰레기 값으로 초기화 된다.
    ```
```
  void SimpleFunc(void) {
    static int num1 = 0;        // 사실은 존재하지 않는다고 생각하면 돼!
    int num2 = 0;
    num1++, num2++;
    printf("static: %d, local: %d \n", num1, num2);
  }

  int main(void) {
    int i;
    for (i = 0; i < 3; i++) {
      SimpleFunc();
    }
    return 0;
  }
```
- 결과:
  ```
    static: 1, local: 1
    static: 2, local: 1
    static: 3, local: 1
  ```
- static 지역변수로만 해결이 가능한 문제는 존재하지 않는다! 전역변수로 대체 가능하므로!
- 하지만, static 지역변수는 전역변수보다 안정적이다!
- 이런 특성 때문에 일반적으로 'static 지역변수'라는 표현 대신에 **static 변수** 라는 표현을 사용한다.

#### 9.3.3 보다 빠르게! register 변수
- 지역변수에 register라는 선언을 추가한 변수를 가리킨다.
  ```
    int SoSimple(void) {
      register int num = 3;
    }
  ```
- 이 경우, num은 CPU에 존재하는 '레지스터'라는 메모리 공간에 저장될 확률이 높아진다.
- 레지스터는 CPU내에 존재하는 그 크기가 매우 작은 메모리이다.
- 그러나, CPU내에 존재하기 때문에 이 메모리에 저장된 데이터를 대상으로 하는 연산은 매우 빠르다.
- 컴파일러는 이 선언을 힌트로 해서 레지스터의 활용 여부를 결정한다. (100% 레지스터에 저장되는게 아니라는 뜻)
- 반대로, 아무런 선언을 하지 않았음에도 컴파일러가 레지스터에 할당해야겠다고 판단하면 그 변수는 레지스터에 할당된다.
- 레지스터는 하나의 변수가 죽치고 자리하기엔 너무나도 중요하고 비싼 메모리 공간이므로 전역변수에는 선언 불가.

### 9.4 재귀함수에 대한 이해
- **재귀함수**: 함수 내에서 자기 자신을 다시 호출하는 함수를 의미한다.
  ```
    void Recursive(int num) {
      if (num <= 0) {   // 재귀의 탈출조건
        return;         // 재귀의 탈출!
      }
      printf("Recursive Call! \n");
      Recursive(num-1);
    }
  ```
- Recursive 함수를 실행하는 중간에 다시 Recursive 함수가 호출되면,
- **Recursive 함수의 복사본을 하나 더 만들어서 복사본을 실행하게 된다.**
- 재귀함수에 탈출조건이 없을 경우 계속해서 호출되는 문제가 발생한다.
