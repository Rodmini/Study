# C언어의 기본
## 1. 이것이 C언어다.
### 1.1 프로그래밍 언어란?
- 사람과 컴파일러가 이해할 수 있는 약속된 형태의 언어를 의미한다.

### 1.2 컴파일러의 역할은?
- 프로그래밍 언어로 작성한 프로그램을 컴퓨터가 이해할 수 있도록 기계어로 번역하는 역할을 한다.
- **컴파일(compile)**: 이렇게 번역하는 일 자체를 가리킴

### 1.3 C언어의 역사와 특징
- 1971년경 UNIX 운영체제의 개발을 위해 Dennis Ritchie와 Ken Thompson이 함께 설계한 범용적인 고급(high-level) 언어이다.
- ALGOL 60(1960년) -> CPL(1963년) -> BCPL(1969년) -> B언어(1970년) -> C언어(1971년)
- 기존의 UNIX 운영체제
  + 어셈블리(assembly) 언어. 저급(low-level)언어로 만들어짐.
  + 하드웨어의 의존도가 높았다 (= 이식성이 낮다)
  + ex. 인텔 CPU를 기반으로 구현된 프로그램은 AMD 기반의 시스템에서 동작하지 않았다 -> 똑같은 기능의 프로그램이라도 CPU의 종류에 따라서 별도로 구현해야 했음.
- C언어의 개발로 인해 UNIX 운영체제의 90% 이상이 C언어로 대체됨.
- 저급언어(low-level) vs 고급언어(high-level)
  + 질(quality)의 차이를 의미하는 것이 아니다.
  + 저급언어에 가까울수록 사람보다 컴퓨터가 이해하기 쉬운 언어가 된다.
  + 고급언어에 가까울수록 사람이 이해하기 쉬운 언어가 된다.

### 1.4 C언어의 장점
- 절차지향적 특성을 지닌다 (정해진 순서의 실행흐름을 중시)
  + 인간의 일반적인 생각방식이 절차지향에 가까우므로 익숙해지는데 오랜 시간이 걸리지 않는다.
- 이식성이 좋다
  + C언어로 작성된 프로그램은 CPU의 종류에 상관없이 실행이 가능하고, 운영체제의 차이에도 덜 민감하다.
- 좋은 성능을 보인다.
  + 어떻게 만드냐에 따라 성능은 달라질 수 있으나, 기본적으로 성능에 민감한 소프트웨어의 개발에 주로 사용된다.
  + 사용하는 메모리의 양이 상대적으로 적고, 속도를 저하시키는 요소들을 최소화한 언어이기 때문.

## 2. 간단한 용어 정리
- **소스코드(source code)**: 자신이 원하는 것을 논리적으로 표현하는 과정에서 작성된 코드
- **코딩(coding)**: 소스코드를 만들어가는 과정
- **함수(function)**: 적절한 입력과 그에 다른 출력이 존재
- **세미콜론(;)**: C언어에서 문장의 끝을 표현하기 위함. 조건문이나 반복문 같은 컨트롤 문장에는 세미콜론이 붙지 않는다.
- **이스케이프 시퀀스(escape sequence)**: 큰따옴표로 표현되는 문자열 안에서 특수한 의미로 사용되는 문자. ex.`\n`: 개행. 줄바꿈.
- **printf 함수**: 함수호출 시 전달되는 문자열을 모니터에 출력하는 기능. 누구나 가져다 쓸 수 있도록 기본적으로 제공되는 함수
- **scanf 함수**: 키보드로부터 다양한 형태의 데이터를 입력받는 함수. 공백을 기준으로 데이터를 구분한다.
- **표준함수**: 기본적으로 제공되는 함수
- **표준 라이브러리**: 표준함수들의 모임
- **main함수의 return문**
  + main 함수는 프로그램이 시작되면 자동으로 호출되는 함수이다. 호출의 주체는 Windows나 Linux 같은 운영체제.
  + main 함수에서 `return 0`을 했을 때 0은 운영체제에게 전달된다 -> 프로그램의 종료상태를 알리는 용도.
  + 보통 0은 정상적인 종료의 상황에서 전달하는 값이다. 비정상적인 상황으로 인해서 종료될 때는 일반적으로 0이 아닌 값을 전달한다.
- **주석(comment)**: 프로그램 내에 삽입된 메모. 컴파일의 대상에서 제외가 되므로 프로그램의 실행결과에 영향을 미치지 않는다.
  + 블록 단위 주석은 중첩될 수 없지만, 행 단위 주석은 블록 단위 주석의 내부에 포함될 수 있다.
- **서식문자(conversion specifier)**: 출력의 형태를 지정하는 용도로 사용됨. ex.`%d\n`
- **연산자(operator)**: C언어를 이용해서 특정연산을 요구할 때 사용되는 약속된 기호
- **변수(variable)**: 값을 저장할 수 있는 메모리 공간에 붙은 이름, 혹은 메모리 공간 자체를 가리킴. 임의의 값을 대입할 수 있는 문자

## 3. 변수와 연산자
### 3.1 변수 선언 시 주의할 사항
- 1999년도에 발표된 C언어의 표준에서는 변수의 선언위치에 아무런 제한을 두고 있지 않으나,
- 상당수의 컴파일러가 변수의 선언문이 중괄호의 앞부분에 위치할 것을 요구하므로
- 컴파일러가 지원하는 변수선언의 위치에 상관없이 중괄호의 앞부분에 변수를 선언하는 것이 좋다.

### 3.2 변수 이름을 지을 때 규칙
- 변수의 이름은 알파벳, 숫자, 언더바로 구성됨
- C언어는 대소문자를 구분한다. Num과 num은 서로 다른 변수.
- 변수의 이름은 숫자로 시작할 수 없고, 키워드도 변수의 이름으로 사용할 수 없다.
- 이름 사이에 공백 삽입 불가능

### 3.3 C언어의 다양한 연산자
- **이항 연산자(binary operator)**: 두 개의 피연산자를 요구하는 연산자
- 대입연산자(=), 산술연산자(+,-,\*,/,%)
- 복합 대입 연산자(\*=,/=,%=,+=,-=,<<=,>>=,&=,^=,|=)
- 부호 연산의 의미를 갖는 +, - 연산자
  + ex. num1 = -num2
- 증가, 감소 연산자
  + 후위 증가 및 후위 감소 연산 시에는 소괄호의 영향을 받지 않고, 다음 문장으로 넘어가야만 비로소 값의 증가 및 감소가 이뤄진다.
- 관계연산자(<,>,==,!=,<=,>=)
  + 대소의 동등의 관계를 따지는 연산자. (= 비교연산자)
  + 조건을 만족하면 1(true)을, 만족하지 않으면 0(false)을 반환한다.
- 논리연산자(&&,||,!)
  + AND(논리곱), OR(논리합), NOT(논리부정)을 표현하는 연산자.
- **논리연산자 보다 관계연산자가 먼저 실행된다.**
- **C언어는 0이 아닌 모든 값을 참(true)으로 간주한다.**
- 콤마연산자(,): 다른 연산자들과 달리, 연산의 결과가 아닌 **구분** 을 목적으로 주로 사용된다.

### 3.4 C언어의 표준 키워드 (Keyword)
- 기능적 의미가 정해져서 C언어의 문법을 구성하는 단어들. ex. int, return ...
- 키워드들은 변수나 함수의 이름으로 사용할 수 없다. 프로그래머가 다른 용도로 사용할 수 없도록 제한되어 있다.
- `auto`, `_Bool`, `break`, `case`, `char`, `_Complex`, `_Imaginary`, `return`, `restrict`, `short`, `signed`,
- `const`, `continue`, `default`, `do`, `double`, `else`, `enum`, `extern`, `float`, `for`, `goto`, `if`, `sizeof`,
- `static`, `struct`, `switch`, `typedef`, `union`, `unsigned`, `void`, `volatile`, `while` ...

## 4. 데이터 표현방식의 이해
### 4.1 컴퓨터가 데이터를 표현하는 방식
- 컴퓨터는 2진수를 기반으로 데이터를 표현하고 연산도 진행한다.
- **2진수**: 두 개의 기호(=숫자)를 이용해서 데이터를 표현하는 방식
- **10진수**: 10개의 기호를 이용해서 데이터를 표현하는 방식
- **16진수**: 16개의 기호를 이용해서 데이터를 표현하는 방식. **16진수는 대소문자를 구분하지 않는다.**
- **n진수에서의 n**: 데이터를 표현하는데 사용하는 기호의 갯수를 의미한다.
- 16진수를 사용하는 이유?
  + 컴퓨터는 0과 1로만 데이터를 표현하기 때문에 2진수만 알아도 될 것 같지만, 2진수로 데이터를 표현하게 되면 그 길이가 길어져서 표현하기에도, 한 눈에 파악하기에도 어려움이 따른다.
  + 그러므로 16진수를 이용하면 2진수를 간단히 표현 및 파악 할 수 있다. 2진수 네 개는 16진수 하나로 표현이 가능하기 때문

### 4.2 데이터의 표현단위 비트(Bit), 바이트(Byte)
- **비트(Bit)**: 컴퓨터가 표현하는 데이터의 최소단위. 2진수 값 하나를 저장할 수 있는 메모리의 크기를 뜻한다.
- **바이트(Byte)**: 비트를 여덟 개 묶은 것. 1 Byte = 8 Bit
- **n개의 비트를 가지고 나타낼 수 있는 데이터의 수는 2^n개이다.**
- ex. 00010001 은 2^4와 2^0의 합으로 쉽게 계산이 가능하다.

### 4.3 8진수와 16진수를 이용한 데이터 표현
```c
  int num1 = 10;      // 특별한 선언이 없을 경우 10진수의 표현
  int num2 = 0xA;     // 0x로 시작하면 16진수로 인식
  int num3 = 012;     // 0으로 시작하면 8진수로 인식
```
- **표현의 방식이 다르다고 해서 저장되는 값이 달라지는 것은 아니다**
- 16진수 A와 8진수 12는 둘 다 10진수로 10이다. 즉, 변수에 초기화되는 값은 모두 동일하지만, 초기화에 사용된 표현의 방식에만 차이가 있을뿐이다.
- 컴퓨터는 내부적으로 2진수의 형태로 값을 저장한다.

### 4.4 정수와 실수의 표현 방식
- 정수를 표현하는데 있어서 가장 왼쪽에 존재하는 비트는 부호를 표현하는데 사용된다.     **양수라면 0, 음수라면 1** 을 저장하여 부호를 표시한다.
- **MSB(Most Significant Bit)**: 가장 중요한 비트라는 뜻. 가장 왼쪽에 존재하는 부호(+,-)를 표현하는데 사용되는 비트. 이 비트의 설정에 따라 정수의 부호가 달라진다.
- ex. 00000101 => MSB가 0이고 데이터가 0000101이므로 +5를 의미한다.
- **음의 정수를 표현할 때에는 2의 보수를 취해야 한다.**
- 'MSB만 1로 설정해주면 되는 것 아님??? 10000101이라면 -5로 해설하면 될 것 같은데' (x) 틀린표현
- 음수 표현이 제대로 된 것인지 확인하려면 음수값과 양수값을 더해서 0이 나오는지 확인해보면 된다. 그러나 00000101 + 10000101의 값이 0이 아니므로 음수의 표현이 잘못된 것.
- **음수의 표현방법**
  + 양의 정수 값에 **1의 보수** 를 취한다.
  + 1을 더한다. 끝
  + ex. 00000101 => 11111010 => 11111011
  + 00000101 + 11111011 의 값이 0이 되는 것을 확인할 수 있다.(올림수는 버려버림)
  + **2의 보수법**: 음수를 표현하기 위해서 거쳤던 과정을 가리킨다. 1의 보수를 취하고 1을 더하는 과정이 2의 보수를 구하는 과정이다.
- **실수의 표현방식**
  + **+-(1.m) * 2^(e-127)** 앞의 1바이트가 e, 뒤의 1바이트가 m. => 부동 소수점 방식
  + 넓은 범위의 실수를 표현할 수 있지만, 컴퓨터가 실수를 표현하는 방식에는 **오차** 가 존재한다.
  + 우리가 표현하고자 하는 실수의 값을 정확하게 표현하는 것이 아니라, 문제가 없을 만큼의 근사치를 통해서 실수를 표현하게 된다.
  + **부동 소수점 오차**: 실수를 표현하는데 있어 발생하는 오차
  + 부동 소수점 오차는 C언어만의 문제일까?
    - No! 부동 소수점 오차는 프로그래밍 언어에 상관없이 발생하는 문제이다. 컴퓨터의 실수표현에 대한 한계에서 비롯된 것이므로...

### 4.5 비트 연산자
- 비트 단위로 연산을 진행하는 비트 연산자는 주로 하드웨어 관련 프로그래밍에 활용되지만,
- 그 이외의 영역에서도 사용되어 메모리 공간의 효율성을 높이고 연산의 수를 줄이는 요인이 되기도 한다.
- **& 연산자: 비트단위 AND** : 두 개의 비트가 모두 1일 때 1을 반환하는 연산
- **| 연산자: 비트단위 OR** : 두 개의 비트 중 하나라도 1이면 1을 반환하는 연산
- **^ 연산자: 비트단위 XOR** : 두 개의 비트가 서로 다른 경우에 1을 반환하는 연산
- **~ 연산자: 비트단위 NOT** : ~연산은 비트를 0에서 1로, 1에서 0으로 반전시키기 때문에 **보수연산** 이라고도 불린다. 단항연산자로서 반전 결과만 반환한다.
  + MSB도 반전되어 부호마저 바뀐다.
  + ex. 00000000 00000000 00000000 00001111 (15) => 11111111 11111111 11111111 11110000 (-16)
  + **음의 정수 크기 확인하기**
    - 2진수로 표현된 음의 정수는 양의 정수와 달리 그 값의 크기를 바로 계산하기가 쉽지 않다. => **2의 보수를 취해보면 쉽게 확인이 가능하다.**
    - ex. 11111111 11111111 11111111 11110000 (-16) => MSB가 1이므로 음수라는 것을 알 수 있다! 크기를 계산하기 위해 2의 보수를 취해보자!
    -  => 00000000 00000000 00000000 00010000 (+16) => 양의 정수이므로 크기가 16임을 쉽게 확인할 수 있다!
    - **2의 보수를 취하는 것은 -1을 곱하는 결과로 이어지기 때문에, 음의 정수에 2의 보수를 취하여 그 크기를 확인할 수 있는 것!**
- **<<연산자: 비트의 왼쪽 이동(Shift)** : 비트 열을 n칸 왼쪽으로 이동시킨 **결과** 만 반환한다.
  + ex. num << 3    // num의 비트 열을 왼쪽으로 3칸 이동
  + 비트의 이동으로 인해서 생기는 오른쪽 빈 칸은 0으로 채워지고, 이동으로 인해 밀려나는 왼쪽 비트들(4바이트를 넘어서는)은 그 값이 1이더라도 그냥 버려진다.
  + **비트의 열을 왼쪽으로 1칸씩 이동시킬 때마다 정수의 값은 두 배가 된다.**
  + **비트의 열을 오른쪽으로 1칸씩 이동시킬 때마다 정수의 값은 2로 나누어진다.** => 상황에 따라 곱셈, 나눗셈 연산 대신 대체가능!
  + CPU의 입장에서는 곱셈과 나눗셈이 비트의 이동보다 부담스러운 연산이므로, 비트연산 대체 사용을 통해 성능을 향상 시킬 수 있다.
- **>>연산자: 비트의 오른쪽 이동(Shift)** : 비트 열을 n칸 오른쪽으로 이동시킨 **결과** 만 반환한다.
  + \>>연산자와 <<연산자의 가장 큰 차이점은 비트의 열을 이동시키는 방향!!!!
  + ex. num1 >> num2 => num2의 크기 만큼 num1의 비트 열을 오른쪽으로 이동한 결과가 반환된다.
  + 비트의 이동으로 인해 밀려나는 오른쪽의 비트들은 소멸되고, 이동으로 인해서 생긴 왼쪽의 빈자리는 0으로 채워진다.
  + 그러나 만약 음수라면????? ex. -16의 비트 열을 2칸씩 오른쪽으로 이동시키면 어떻게 될까?
    - 11111111 11111111 11111111 11110000    // -16   
    - 이 결과는 CPU에 따라서 달라진다. 음의 값을 유지하기 위해서 1을 채우는 CPU도 있고, 0을 채우는 CPU도 있기 때문
      + 00111111 11111111 11111111 11111100     // 0이 채워진 경우
      + 11111111 11111111 11111111 11111100     // 1이 채워진 경우

## 5. 상수와 기본 자료형
### 5.1 자료형의 이해
- **자료형(data type)**: 데이터를 표현하는 방법
- **변수(variable)**: 데이터의 저장을 위해서 할당된 메모리 공간에 붙여진 이름

### 5.2 기본 자료형의 종류와 데이터의 표현범위
- 정수형
  + **char** 1바이트 (-128 ~ +127)
  + **short** 2바이트 (-32,768 ~ +32,767)
  + **int** 4바이트 (-2,147,483,648 ~ +2,147,483,647)
  + **long** 4바이트 (-2,147,483,648 ~ +2,147,483,647)
  + **long long** 8바이트 (-9,223,372,036,854,775,808 ~ +9,223,372,036,854,775,807)
- 실수형
  + **float** 4바이트 (+-3.4 * 10^(-37) ~ +-3.4 * 10^38)
  + **double** 8바이트 (+-1.7 * 10^(-307) ~ +-1.7 * 10^308)
  + **long double** 8바이트 이상 (double 이상의 표현범위)
- **short와 int는 최소 2바이트이되, int는 short와 크기가 같거나 더 커야 한다.**
- **자료형 별 크기를 정확하게 제한하고 있지 않다. 자료형 별 크기는 컴파일러마다 차이를 보인다.**
- **메모리의 효율적 사용을 위해서 다양한 크기의 자료형이 존재하는 것이다.**

### 5.3 연산자 sizeof를 이용하면 자료형의 크기를 확인할 수 있다.
- 일반적으로 sizeof를 사용할 때 소괄호로 감싸기 때문에 함수로 오인하기 쉽다.
- int 같은 자료형의 이름에는 소괄호가 필수지만, 나머지 피연산자에 대해서는 소괄호 사용이 선택적이다.
- **sizeof는 함수가 아니라 연산자이다!!!!**

### 5.4 정수를 표현 및 처리하기 위한 일반적인 자료형의 선택
```c
  printf("size of char add: %d \n", sizeof(num1 + num2));     // 4 출력
  printf("size of short add: %d \n", sizeof(num3 + num4));    // 4 출력
```
- char형 덧셈결과로 반환된 값의 크기는 1바이트, short형 덧셈결과로 반환된 값의 크기는 2바이트가 될 것 같은데,
- 출력결과에서는 그 크기가 모두 4바이트이다 !!!!
- **일반적으로 CPU가 처리하기에 가장 적합한 크기의 정수 자료형을 int로 정의한다.**
- **따라서 int형 연산의 속도가 다른 자료형의 연산속도에 비해서 동일하거나 더 빠르다.**
- 이렇듯 int형 연산이 CPU가 성능을 내기에 가장 좋은 연산이다 보니, int보다 작은 크기의 데이터는 int형 데이터로 바꿔서(형 변환) 연산이 진행된다.
- 연산의 횟수가 빈번한 경우에는 저장되는 값의 크기가 작더라도 int형 변수를 선언하는 것이 좋다.
  + 그럼 char나 short형 변수는 불필요한 것인가?
    - No! **데이터의 양이 많아서 연산속도보다 데이터의 크기를 줄이는 것이 더 중요한 데이터들** 의 경우에 사용하면 좋다!
    - ex. MP3같은 음성 데이터, 영상 데이터 같이 크기에 민감한 데이터들

### 5.5 실수를 표현 및 처리하기 위한 일반적인 자료형의 선택
- 실수 자료형의 선택에 있어서 가장 중요한 요소는 **정밀도** 이다.
  + float의 소수점 이하 정밀도: 6자리
  + double의 소수점 이하 정밀도: 15자리    // 소수점 이하 15자리까지는 오차가 발생하지 않음을 보장한다.
  + long double의 소수점 이하 정밀도: 18자리
- 정수 자료형에서 int를 보편적으로 선택하듯이, 실수 자료형에서는 double형을 보편적으로 선택한다.
- double형 데이터를 출력할 때는 서식문자 `%f`를 사용하지만, double형 데이터를 입력받을 땐 서식문자 `%lf`를 사용한다.

### 5.6 unsigned를 붙여서 0과 양의 정수로만 표현하기
- 정수 자료형의 이름에 한해서 unsigned 선언을 추가하면 0 이상의 값만 표현하는 자료형이 되어 값의 범위가 두 배 더 넓어지게 된다.
- ex. char형 변수의 경우(-128 ~ +127) => (0 ~ +255)
- 기본 자료형의 가장 왼쪽 비트인 MSB는 데이터의 부호를 결정짓는데 사용하지만 unsigned를 붙이게 되면 MSB조차 값의 크기를 나타내는 비트로 사용하게 된다.
- int와 signed int, short와 signed short는 같은 표현 (signed 키워드를 생략한 것일뿐)
- 그러나 char를 unsigned char로 처리하는 컴파일러도 있기 때문에 char는 signed char와 다를 수 있다!
  + char형 변수를 선언해서 음의 정수를 저장하는 경우에는 signed 선언을 추가하기도 한다.

### 5.7 문자의 표현을 위한 약속! 아스키(ASCII) 코드!
- ASCII: American Standard Code for Information Interchange
- 미국 표준 협회(ANSI: American National Standards Institute)에 의해서 제정된 표준
- **정수는 출력의 방법에 따라서 문자의 형태로도, 숫자의 형태로도 출력이 가능하다**
- 문자를 저장하는 데에는 int형 변수보다 char형 변수가 더 적합하다.
  + 아스키 코드 값은 0~127 이므로 char형 변수로 충분히 저장 가능함.
  + int형 변수에도 저장은 가능하나 메모리의 효율적 사용을 위해 char형 사용 권장.
  + int형으로 선언하는 것이 빠르지만 **연산** 에 한해서!!! => 문자로 연산을 할 일은 없으니 char형 변수가 낫다!
- char는 문자형일까? 정수형일까?
  + char형은 문자의 표현을 목적으로 정의된 자료형이라 문자형으로 분류되기도 하지만
  + 문자도 정수의 형태로 표현이 되고, 실제로 char형 변수에 저장되는 것은 정수이므로 **char는 정수형** 이다.

### 5.8 상수에 대한 이해
- **상수란, 변경이 불가능한 데이터를 뜻한다.**
- **int, double과 같은 자료형을 근거로 표현이 된다.**

#### 5.8.1 이름을 지니지 않는 리터럴(Literal) 상수
```c
  int num = 30 + 40;    // 30과 40은 상수이다!
```
- CPU가 30+40의 연산을 수행하려면 이 값들이 메모리상에 존재해야 한다. 메모리에 존재하지도 않는 값을 대상으로 덧셈연산이 불가능하기 때문이다.
- 즉, 덧셈의 과정을 살펴보면
  + 정수 30, 40이 메모리 공간에 상수의 형태로 저장된다.
  + 두 상수를 기반으로 덧셈이 진행된다.
  + 덧셈의 결과로 얻어진 정수 70이 변수 num에 저장된다.
- 변수 num과 달리 위 두 상수의 값은 할당된 메모리 공간에 이름이 없다.
- **리터럴(literal) 상수: 할당된 메모리 공간에 이름이 없는 상수를 가리킴** 또는 그냥 '리터럴'
- 변수가 아닌 상수를 위한 자료형도 존재한다!!

#### 5.8.2 접미사를 이용한 다양한 상수의 표현
- int, double 이외의 자료형을 기반으로 상수를 표현하려면?
  + 해당 자료형을 의미하는 접미사를 붙여주면 된다.
  ```c
    float num1 = 5.789;           // 경고 메시지 발생
    float num2 = 3.24 + 5.12;     // double형 데이터를 float형 변수에 저장하였으니 데이터가 잘릴수도!

    float num3 = 5.789f;          // 경고 메시지 발생 안 함
    float num4 = 3.24F + 5.12F    // 소문자 대신 대문자 F를 써도 됨
  ```
- 접미사들은 대소문자를 구분하지 않으므로 눈에 잘 띄도록 상황에 맞게 대소문자를 선택하면 된다.
- **정수형 상수의 표현을 위한 접미사**
  + **U**: unsigned int, `unsigned int n = 1025U`
  + **L**: long, `long n = 2467L`
  + **UL**: unsigned long, `unsigned long n = 3456UL`
  + **LL**: long long, `long long n = 5768LL`
  + **ULL**: unsigned long long, `unsigned long long n = 8979ULL`
- **실수형 상수의 표현을 위한 접미사**
  + **F**: float, `float f = 3.15F`
  + **L**: long double, `long double f = 5.789L`

#### 5.8.3 이름을 지니는 심볼릭(Symbolic) 상수: const 상수
- 심볼릭 상수는 변수와 마찬가지로 이름을 지니는 상수이다.
  + 심볼릭 상수를 표현하는 두 가지 방법
    - 1. const 키워드를 사용하는 방법
    - 2. 매크로를 이용하는 방법 (Chapter 26. 추후 언급)
- **const 상수**
  + 변수 선언 시 const 선언만 추가하면 되지만, 상수이므로 선언과 동시에 초기화를 해야 한다!
  ```c
    const int MAX = 100;      // MAX는 상수이므로 값 변경 불가능
    const double PI = 3.1415; // PI는 상수이므로 값 변경 불가능
  ```
- **상수의 이름은 모두 대문자로 표시하고, 둘 이상의 단어로 연결할 때에는 언더바 사용하는 것이 관례!**

### 5.9 자료형의 변환
- char형으로 표현되어 있는 데이터의 표현방식을 int로 바꾸거나, 혹은 그 반대
- 즉, **데이터의 표현방식을 바꾸는 것** 을 의미한다.
#### 5.9.1 대입연산의 전달과정에서 발생하는 자동 형 변환 (묵시적 형 변환)
```c
  double num1 = 245;      // int를 double로 자동 형 변환. 245.0 저장
  int num2 = 3.1415;      // double을 int로 자동 형 변환. 3 저장
```
- 실수형 데이터를 정수형 데이터로 변환하는 과정에서는 '소수부의 손실'이 발생한다.
```c
  int num3 = 129;     // 00000000 00000000 00000000 10000001
  char ch = num3;     // 10000001 (-127)
```
- 상위 바이트의 손실로 인해서 부호가 바뀌는 경우도 있으니 주의해야 한다.
- 대표적인 형 변환의 사례
  + 정수를 실수로 형 변환하는 경우
    - 실수의 표현범위가 정수에 비해 훨씬 넓기 때문에 데이터의 손실은 없으나, 오차는 존재하게 된다.
  + 실수를 정수로 형 변환하는 경우
    - 정수는 소수점 이하의 값을 표현하지 못하므로, 소수점 이하의 값은 버려진다.
  + 바이트 크기가 큰 정수를 바이트 크기가 작은 정수로 형 변환하는 경우
    - 변환하고자 하는 정수의 바이트 크기에 맞춰 상위 바이트를 단순히 소멸시킨다.
    - 이 때, 부호가 변경될 수 있으므로 주의해야한다.
- **데이터의 표현범위가 보다 넓은 자료형으로의 형 변환은, 데이터의 손실이 발생하지 않지만**
- **데이터의 표현범위가 좁은 자료형으로의 형 변환은, 데이터의 손실이 발생할 수 있다!**
#### 5.9.2 정수의 승격(Integral Promotion)에 의한 자동 형 변환
- 일반적으로 CPU가 처리하기에 가장 적합한 크기의 정수 자료형을 int로 정의하므로, 다른 자료형의 연산속도에 비해서 동일하거나 더 빠르다.
- 따라서, int 보다 작은 크기의 정수형 데이터는 int형 데이터로 자동 형 변환이 발생되어 연산이 진행된다.
```c
  short num1 = 15, num2 = 25;         
  short num3 = num1 + num2;           // num1과 num2가 int형으로 형 변환
```
- 이러한 형태의 형 변환을 **정수의 승격(Integral Promotion)** 이라 한다.
- 위의 코드에서는 정수의 승격만 일어난 것이 아니라, num1+num2의 계산결과 4바이트 크기의 int형 정수를 short형 변수 num3에 저장하기 위해서 대입연산의 전달과정에서 발생하는 형 변환이 다시 일어나게 된다.
- 정말로 int형 연산이 short형 연산보다 빠를까?
  + 사실 오늘날의 컴퓨팅 환경에서 정수형 데이터의 연산속도는 정수의 크기에 상관없이 거의 동일하다.
  + 또 CPU의 성능 및 구조가 이전과는 달리 많이 개선되어 연산속도 차이는 크게 나지 않으나,
  + 세상에는 많은 종류의 CPU가 있고, 또 새로운 CPU의 등장도 고려해야 하기 때문에 C언어가 정의하는 '정수의 승격'은 여전히 유의미하다.
#### 5.9.3 피연산자의 자료형 불일치로 발생하는 자동 형 변환
```c
  double num1 = 5.15 + 19;
```
- 정수와 실수는 표현방식이 다르므로 사실상 덧셈이 불가능하다. 형 변환 필요!
- **피연산자의 자료형이 일치하지 않아서 발생하는 자동 형 변환은 데이터의 손실을 최소화하는 방향으로 진행된다.**
  + 최소화 기준 int => long => long long => float => double => long double
  + 바이트 크기를 기준으로 정한 우선순위가 아니라, **데이터 손실의 최소화** 를 최상위 목적으로 두고 정한 것

#### 5.9.4 명시적 형 변환: 강제로 일으키는 형 변환
- **명시적 형 변환**: 형 변환 연산자를 이용해서 강제로 형 변환을 명령하는 것
```c
  int num1 = 3, num2 = 4;
  double divResult;
  divResult = num1 / num2;
```
- 결과는 0.000000 이 된다. 연산결과의 자료형은 피연산자의 자료형과 일치하기 때문이다.
```c
  divResult = (double)num1 / num2;
```
- 이렇게 하면 `3.0 / num2` 가 되므로 num2가 자동 형 변환되어 결과값이 0.75가 된다.
- **형 변환 연산자(type casting operator)**: 형 변환을 명령할 때 사용되는 소괄호. ex. (double)num1
  + C언어에서의 소괄호는 연산의 순서를 지정하기 위해서도 사용되지만(수학적의미), 형 변환을 명령할 때도 사용된다.
  ```c
    int num1 = 3;
    double num2 = 2.5 * num1;
  ```
  + 이 처럼 자동 형 변환이 발생하는 경우에는, `double num2 = 2.5 * (double)num1`처럼 명시해주는게 좋다.
  + 형 변환이 발생하는 위치를 표시해서 코드의 분석을 돕는 효과가 있기 때문이다.
